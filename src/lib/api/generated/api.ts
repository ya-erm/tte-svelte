/* tslint:disable */
/* eslint-disable */
/**
 * Tinkoff Invest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.7
 * Contact: al.a.volkov@tinkoff.ru
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import globalAxios, { type AxiosPromise, type AxiosInstance, type AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  [key: string]: object | any;

  /**
   *
   * @type {string}
   * @memberof ProtobufAny
   */
  '@type'?: string;
}
/**
 *
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
  /**
   *
   * @type {number}
   * @memberof RpcStatus
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof RpcStatus
   */
  message?: string;
  /**
   *
   * @type {Array<ProtobufAny>}
   * @memberof RpcStatus
   */
  details?: Array<ProtobufAny>;
}
/**
 * Уровень доступа к счёту.
 * @export
 * @enum {string}
 */

export const V1AccessLevel = {
  Unspecified: 'ACCOUNT_ACCESS_LEVEL_UNSPECIFIED',
  FullAccess: 'ACCOUNT_ACCESS_LEVEL_FULL_ACCESS',
  ReadOnly: 'ACCOUNT_ACCESS_LEVEL_READ_ONLY',
  NoAccess: 'ACCOUNT_ACCESS_LEVEL_NO_ACCESS',
} as const;

export type V1AccessLevel = typeof V1AccessLevel[keyof typeof V1AccessLevel];

/**
 * Информация о счёте.
 * @export
 * @interface V1Account
 */
export interface V1Account {
  /**
   * Идентификатор счёта.
   * @type {string}
   * @memberof V1Account
   */
  id?: string;
  /**
   *
   * @type {V1AccountType}
   * @memberof V1Account
   */
  type?: V1AccountType;
  /**
   * Название счёта.
   * @type {string}
   * @memberof V1Account
   */
  name?: string;
  /**
   *
   * @type {V1AccountStatus}
   * @memberof V1Account
   */
  status?: V1AccountStatus;
  /**
   * Дата открытия счёта в часовом поясе UTC.
   * @type {string}
   * @memberof V1Account
   */
  openedDate?: string;
  /**
   * Дата закрытия счёта в часовом поясе UTC.
   * @type {string}
   * @memberof V1Account
   */
  closedDate?: string;
  /**
   *
   * @type {V1AccessLevel}
   * @memberof V1Account
   */
  accessLevel?: V1AccessLevel;
}
/**
 * Статус счёта.
 * @export
 * @enum {string}
 */

export const V1AccountStatus = {
  Unspecified: 'ACCOUNT_STATUS_UNSPECIFIED',
  New: 'ACCOUNT_STATUS_NEW',
  Open: 'ACCOUNT_STATUS_OPEN',
  Closed: 'ACCOUNT_STATUS_CLOSED',
} as const;

export type V1AccountStatus = typeof V1AccountStatus[keyof typeof V1AccountStatus];

/**
 * Тип счёта.
 * @export
 * @enum {string}
 */

export const V1AccountType = {
  Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
  Tinkoff: 'ACCOUNT_TYPE_TINKOFF',
  TinkoffIis: 'ACCOUNT_TYPE_TINKOFF_IIS',
  InvestBox: 'ACCOUNT_TYPE_INVEST_BOX',
} as const;

export type V1AccountType = typeof V1AccountType[keyof typeof V1AccountType];

/**
 * Операция начисления купонов.
 * @export
 * @interface V1AccruedInterest
 */
export interface V1AccruedInterest {
  /**
   *
   * @type {string}
   * @memberof V1AccruedInterest
   */
  date?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AccruedInterest
   */
  value?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AccruedInterest
   */
  valuePercent?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AccruedInterest
   */
  nominal?: V1Quotation;
}
/**
 * Информация об активе.
 * @export
 * @interface V1Asset
 */
export interface V1Asset {
  /**
   *
   * @type {string}
   * @memberof V1Asset
   */
  uid?: string;
  /**
   *
   * @type {V1AssetType}
   * @memberof V1Asset
   */
  type?: V1AssetType;
  /**
   *
   * @type {string}
   * @memberof V1Asset
   */
  name?: string;
  /**
   *
   * @type {Array<V1AssetInstrument>}
   * @memberof V1Asset
   */
  instruments?: Array<V1AssetInstrument>;
}
/**
 * Облигация.
 * @export
 * @interface V1AssetBond
 */
export interface V1AssetBond {
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetBond
   */
  currentNominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  borrowName?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetBond
   */
  issueSize?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetBond
   */
  nominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  nominalCurrency?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  issueKind?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  interestKind?: string;
  /**
   *
   * @type {number}
   * @memberof V1AssetBond
   */
  couponQuantityPerYear?: number;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  indexedNominalFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  subordinatedFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  collateralFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  taxFreeFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  amortizationFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  floatingCouponFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetBond
   */
  perpetualFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  maturityDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  returnCondition?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  stateRegDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetBond
   */
  placementDate?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetBond
   */
  placementPrice?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetBond
   */
  issueSizePlan?: V1Quotation;
}
/**
 * Клиринговый сертификат участия.
 * @export
 * @interface V1AssetClearingCertificate
 */
export interface V1AssetClearingCertificate {
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetClearingCertificate
   */
  nominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetClearingCertificate
   */
  nominalCurrency?: string;
}
/**
 * Валюта.
 * @export
 * @interface V1AssetCurrency
 */
export interface V1AssetCurrency {
  /**
   *
   * @type {string}
   * @memberof V1AssetCurrency
   */
  baseCurrency?: string;
}
/**
 * Фонд.
 * @export
 * @interface V1AssetEtf
 */
export interface V1AssetEtf {
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  totalExpense?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  hurdleRate?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  performanceFee?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  fixedCommission?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  paymentType?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetEtf
   */
  watermarkFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  buyPremium?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  sellDiscount?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetEtf
   */
  rebalancingFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  rebalancingFreq?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  managementType?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  primaryIndex?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  focusType?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetEtf
   */
  leveragedFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  numShare?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetEtf
   */
  ucitsFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  releasedDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  primaryIndexDescription?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  primaryIndexCompany?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  indexRecoveryPeriod?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  inavCode?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetEtf
   */
  divYieldFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  expenseCommission?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  primaryIndexTrackingError?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  rebalancingPlan?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  taxRate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AssetEtf
   */
  rebalancingDates?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  issueKind?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetEtf
   */
  nominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetEtf
   */
  nominalCurrency?: string;
}
/**
 *
 * @export
 * @interface V1AssetFull
 */
export interface V1AssetFull {
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  uid?: string;
  /**
   *
   * @type {V1AssetType}
   * @memberof V1AssetFull
   */
  type?: V1AssetType;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  nameBrief?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  deletedAt?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AssetFull
   */
  requiredTests?: Array<string>;
  /**
   *
   * @type {V1AssetCurrency}
   * @memberof V1AssetFull
   */
  currency?: V1AssetCurrency;
  /**
   *
   * @type {V1AssetSecurity}
   * @memberof V1AssetFull
   */
  security?: V1AssetSecurity;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  gosRegCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  cfi?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  codeNsd?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  status?: string;
  /**
   *
   * @type {V1Brand}
   * @memberof V1AssetFull
   */
  brand?: V1Brand;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  updatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  brCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetFull
   */
  brCodeName?: string;
  /**
   *
   * @type {Array<V1AssetInstrument>}
   * @memberof V1AssetFull
   */
  instruments?: Array<V1AssetInstrument>;
}
/**
 * Идентификаторы инструмента.
 * @export
 * @interface V1AssetInstrument
 */
export interface V1AssetInstrument {
  /**
   *
   * @type {string}
   * @memberof V1AssetInstrument
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetInstrument
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetInstrument
   */
  instrumentType?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetInstrument
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetInstrument
   */
  classCode?: string;
  /**
   *
   * @type {Array<V1InstrumentLink>}
   * @memberof V1AssetInstrument
   */
  links?: Array<V1InstrumentLink>;
}
/**
 * Запрос актива по идентификатору.
 * @export
 * @interface V1AssetRequest
 */
export interface V1AssetRequest {
  /**
   *
   * @type {string}
   * @memberof V1AssetRequest
   */
  id?: string;
}
/**
 * Данные по активу.
 * @export
 * @interface V1AssetResponse
 */
export interface V1AssetResponse {
  /**
   *
   * @type {V1AssetFull}
   * @memberof V1AssetResponse
   */
  asset?: V1AssetFull;
}
/**
 * Ценная бумага.
 * @export
 * @interface V1AssetSecurity
 */
export interface V1AssetSecurity {
  /**
   *
   * @type {string}
   * @memberof V1AssetSecurity
   */
  isin?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetSecurity
   */
  type?: string;
  /**
   *
   * @type {V1AssetShare}
   * @memberof V1AssetSecurity
   */
  share?: V1AssetShare;
  /**
   *
   * @type {V1AssetBond}
   * @memberof V1AssetSecurity
   */
  bond?: V1AssetBond;
  /**
   *
   * @type {V1AssetStructuredProduct}
   * @memberof V1AssetSecurity
   */
  sp?: V1AssetStructuredProduct;
  /**
   *
   * @type {V1AssetEtf}
   * @memberof V1AssetSecurity
   */
  etf?: V1AssetEtf;
  /**
   *
   * @type {V1AssetClearingCertificate}
   * @memberof V1AssetSecurity
   */
  clearingCertificate?: V1AssetClearingCertificate;
}
/**
 * Акция.
 * @export
 * @interface V1AssetShare
 */
export interface V1AssetShare {
  /**
   *
   * @type {V1ShareType}
   * @memberof V1AssetShare
   */
  type?: V1ShareType;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetShare
   */
  issueSize?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetShare
   */
  nominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  nominalCurrency?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  primaryIndex?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetShare
   */
  dividendRate?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  preferredShareType?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  ipoDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  registryDate?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1AssetShare
   */
  divYieldFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  issueKind?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  placementDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetShare
   */
  represIsin?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetShare
   */
  issueSizePlan?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetShare
   */
  totalFloat?: V1Quotation;
}
/**
 * Структурная нота.
 * @export
 * @interface V1AssetStructuredProduct
 */
export interface V1AssetStructuredProduct {
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  borrowName?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetStructuredProduct
   */
  nominal?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  nominalCurrency?: string;
  /**
   *
   * @type {V1StructuredProductType}
   * @memberof V1AssetStructuredProduct
   */
  type?: V1StructuredProductType;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  logicPortfolio?: string;
  /**
   *
   * @type {V1AssetType}
   * @memberof V1AssetStructuredProduct
   */
  assetType?: V1AssetType;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  basicAsset?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetStructuredProduct
   */
  safetyBarrier?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  maturityDate?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetStructuredProduct
   */
  issueSizePlan?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1AssetStructuredProduct
   */
  issueSize?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  placementDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1AssetStructuredProduct
   */
  issueKind?: string;
}
/**
 * Тип актива.
 * @export
 * @enum {string}
 */

export const V1AssetType = {
  Unspecified: 'ASSET_TYPE_UNSPECIFIED',
  Currency: 'ASSET_TYPE_CURRENCY',
  Commodity: 'ASSET_TYPE_COMMODITY',
  Index: 'ASSET_TYPE_INDEX',
  Security: 'ASSET_TYPE_SECURITY',
} as const;

export type V1AssetType = typeof V1AssetType[keyof typeof V1AssetType];

/**
 * Список активов.
 * @export
 * @interface V1AssetsResponse
 */
export interface V1AssetsResponse {
  /**
   *
   * @type {Array<V1Asset>}
   * @memberof V1AssetsResponse
   */
  assets?: Array<V1Asset>;
}
/**
 * Объект передачи информации об облигации.
 * @export
 * @interface V1Bond
 */
export interface V1Bond {
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  isin?: string;
  /**
   *
   * @type {number}
   * @memberof V1Bond
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  exchange?: string;
  /**
   *
   * @type {number}
   * @memberof V1Bond
   */
  couponQuantityPerYear?: number;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  maturityDate?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Bond
   */
  nominal?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  stateRegDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  placementDate?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Bond
   */
  placementPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Bond
   */
  aciValue?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  sector?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  issueKind?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  issueSize?: string;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  issueSizePlan?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Bond
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  floatingCouponFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  perpetualFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  amortizationFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Bond
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Bond
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Bond
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Bond
   */
  realExchange?: V1RealExchange;
}
/**
 * Информация об облигации.
 * @export
 * @interface V1BondResponse
 */
export interface V1BondResponse {
  /**
   *
   * @type {V1Bond}
   * @memberof V1BondResponse
   */
  instrument?: V1Bond;
}
/**
 * Список облигаций.
 * @export
 * @interface V1BondsResponse
 */
export interface V1BondsResponse {
  /**
   *
   * @type {Array<V1Bond>}
   * @memberof V1BondsResponse
   */
  instruments?: Array<V1Bond>;
}
/**
 * Бренд.
 * @export
 * @interface V1Brand
 */
export interface V1Brand {
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  info?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  company?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  sector?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Brand
   */
  countryOfRiskName?: string;
}
/**
 *
 * @export
 * @interface V1BrokerReport
 */
export interface V1BrokerReport {
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  tradeId?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  orderId?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  executeSign?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  tradeDatetime?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  direction?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  ticker?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  price?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  quantity?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  orderAmount?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1BrokerReport
   */
  aciValue?: V1Quotation;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  totalOrderAmount?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  brokerCommission?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  exchangeCommission?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1BrokerReport
   */
  exchangeClearingCommission?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1BrokerReport
   */
  repoRate?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  party?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  clearValueDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  secValueDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  brokerStatus?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  separateAgreementType?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  separateAgreementNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  separateAgreementDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1BrokerReport
   */
  deliveryType?: string;
}
/**
 *
 * @export
 * @interface V1BrokerReportRequest
 */
export interface V1BrokerReportRequest {
  /**
   *
   * @type {V1GenerateBrokerReportRequest}
   * @memberof V1BrokerReportRequest
   */
  generateBrokerReportRequest?: V1GenerateBrokerReportRequest;
  /**
   *
   * @type {V1GetBrokerReportRequest}
   * @memberof V1BrokerReportRequest
   */
  getBrokerReportRequest?: V1GetBrokerReportRequest;
}
/**
 *
 * @export
 * @interface V1BrokerReportResponse
 */
export interface V1BrokerReportResponse {
  /**
   *
   * @type {V1GenerateBrokerReportResponse}
   * @memberof V1BrokerReportResponse
   */
  generateBrokerReportResponse?: V1GenerateBrokerReportResponse;
  /**
   *
   * @type {V1GetBrokerReportResponse}
   * @memberof V1BrokerReportResponse
   */
  getBrokerReportResponse?: V1GetBrokerReportResponse;
}
/**
 * Запрос отмены торгового поручения.
 * @export
 * @interface V1CancelOrderRequest
 */
export interface V1CancelOrderRequest {
  /**
   *
   * @type {string}
   * @memberof V1CancelOrderRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1CancelOrderRequest
   */
  orderId?: string;
}
/**
 * Результат отмены торгового поручения.
 * @export
 * @interface V1CancelOrderResponse
 */
export interface V1CancelOrderResponse {
  /**
   *
   * @type {string}
   * @memberof V1CancelOrderResponse
   */
  time?: string;
}
/**
 * Запрос отмены выставленной стоп-заявки.
 * @export
 * @interface V1CancelStopOrderRequest
 */
export interface V1CancelStopOrderRequest {
  /**
   *
   * @type {string}
   * @memberof V1CancelStopOrderRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1CancelStopOrderRequest
   */
  stopOrderId?: string;
}
/**
 * Результат отмены выставленной стоп-заявки.
 * @export
 * @interface V1CancelStopOrderResponse
 */
export interface V1CancelStopOrderResponse {
  /**
   *
   * @type {string}
   * @memberof V1CancelStopOrderResponse
   */
  time?: string;
}
/**
 * Интервал свечей.
 * @export
 * @enum {string}
 */

export const V1CandleInterval = {
  Unspecified: 'CANDLE_INTERVAL_UNSPECIFIED',
  _1Min: 'CANDLE_INTERVAL_1_MIN',
  _5Min: 'CANDLE_INTERVAL_5_MIN',
  _15Min: 'CANDLE_INTERVAL_15_MIN',
  Hour: 'CANDLE_INTERVAL_HOUR',
  Day: 'CANDLE_INTERVAL_DAY',
} as const;

export type V1CandleInterval = typeof V1CandleInterval[keyof typeof V1CandleInterval];

/**
 * Запрос закрытия счёта в песочнице.
 * @export
 * @interface V1CloseSandboxAccountRequest
 */
export interface V1CloseSandboxAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1CloseSandboxAccountRequest
   */
  accountId?: string;
}
/**
 * Объект передачи информации о купоне облигации.
 * @export
 * @interface V1Coupon
 */
export interface V1Coupon {
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  couponDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  couponNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  fixDate?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Coupon
   */
  payOneBond?: V1MoneyValue;
  /**
   *
   * @type {V1CouponType}
   * @memberof V1Coupon
   */
  couponType?: V1CouponType;
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  couponStartDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Coupon
   */
  couponEndDate?: string;
  /**
   *
   * @type {number}
   * @memberof V1Coupon
   */
  couponPeriod?: number;
}
/**
 * Тип купонов.
 * @export
 * @enum {string}
 */

export const V1CouponType = {
  Unspecified: 'COUPON_TYPE_UNSPECIFIED',
  Constant: 'COUPON_TYPE_CONSTANT',
  Floating: 'COUPON_TYPE_FLOATING',
  Discount: 'COUPON_TYPE_DISCOUNT',
  Mortgage: 'COUPON_TYPE_MORTGAGE',
  Fix: 'COUPON_TYPE_FIX',
  Variable: 'COUPON_TYPE_VARIABLE',
  Other: 'COUPON_TYPE_OTHER',
} as const;

export type V1CouponType = typeof V1CouponType[keyof typeof V1CouponType];

/**
 * Данные по валютам.
 * @export
 * @interface V1CurrenciesResponse
 */
export interface V1CurrenciesResponse {
  /**
   *
   * @type {Array<V1Currency>}
   * @memberof V1CurrenciesResponse
   */
  instruments?: Array<V1Currency>;
}
/**
 * Объект передачи информации о валюте.
 * @export
 * @interface V1Currency
 */
export interface V1Currency {
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  isin?: string;
  /**
   *
   * @type {number}
   * @memberof V1Currency
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Currency
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  exchange?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Currency
   */
  nominal?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Currency
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Currency
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Currency
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Currency
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  isoCurrencyName?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Currency
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Currency
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Currency
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Currency
   */
  realExchange?: V1RealExchange;
}
/**
 * Данные по валюте.
 * @export
 * @interface V1CurrencyResponse
 */
export interface V1CurrencyResponse {
  /**
   *
   * @type {V1Currency}
   * @memberof V1CurrencyResponse
   */
  instrument?: V1Currency;
}
/**
 * Информация о выплате.
 * @export
 * @interface V1Dividend
 */
export interface V1Dividend {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Dividend
   */
  dividendNet?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  paymentDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  declaredDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  lastBuyDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  dividendType?: string;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  recordDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  regularity?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Dividend
   */
  closePrice?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Dividend
   */
  yieldValue?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Dividend
   */
  createdAt?: string;
}
/**
 * Отчёт \"Справка о доходах за пределами РФ\".
 * @export
 * @interface V1DividendsForeignIssuerReport
 */
export interface V1DividendsForeignIssuerReport {
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  recordDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  paymentDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  securityName?: string;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  isin?: string;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  issuerCountry?: string;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  quantity?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1DividendsForeignIssuerReport
   */
  dividend?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1DividendsForeignIssuerReport
   */
  externalCommission?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1DividendsForeignIssuerReport
   */
  dividendGross?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1DividendsForeignIssuerReport
   */
  tax?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1DividendsForeignIssuerReport
   */
  dividendAmount?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1DividendsForeignIssuerReport
   */
  currency?: string;
}
/**
 * Тип действия со списком избранных инструментов.
 * @export
 * @enum {string}
 */

export const V1EditFavoritesActionType = {
  Unspecified: 'EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED',
  Add: 'EDIT_FAVORITES_ACTION_TYPE_ADD',
  Del: 'EDIT_FAVORITES_ACTION_TYPE_DEL',
} as const;

export type V1EditFavoritesActionType =
  typeof V1EditFavoritesActionType[keyof typeof V1EditFavoritesActionType];

/**
 * Запрос редактирования избранных инструментов.
 * @export
 * @interface V1EditFavoritesRequest
 */
export interface V1EditFavoritesRequest {
  /**
   *
   * @type {Array<V1EditFavoritesRequestInstrument>}
   * @memberof V1EditFavoritesRequest
   */
  instruments?: Array<V1EditFavoritesRequestInstrument>;
  /**
   *
   * @type {V1EditFavoritesActionType}
   * @memberof V1EditFavoritesRequest
   */
  actionType?: V1EditFavoritesActionType;
}
/**
 * Избранный инструмент для редактирования.
 * @export
 * @interface V1EditFavoritesRequestInstrument
 */
export interface V1EditFavoritesRequestInstrument {
  /**
   *
   * @type {string}
   * @memberof V1EditFavoritesRequestInstrument
   */
  figi?: string;
}
/**
 * Результат редактирования избранных инструментов.
 * @export
 * @interface V1EditFavoritesResponse
 */
export interface V1EditFavoritesResponse {
  /**
   *
   * @type {Array<V1FavoriteInstrument>}
   * @memberof V1EditFavoritesResponse
   */
  favoriteInstruments?: Array<V1FavoriteInstrument>;
}
/**
 * Объект передачи информации об инвестиционном фонде.
 * @export
 * @interface V1Etf
 */
export interface V1Etf {
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  isin?: string;
  /**
   *
   * @type {number}
   * @memberof V1Etf
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Etf
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  exchange?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  fixedCommission?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  focusType?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  releasedDate?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  numShares?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  sector?: string;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  rebalancingFreq?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Etf
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Etf
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Etf
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Etf
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Etf
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Etf
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Etf
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Etf
   */
  realExchange?: V1RealExchange;
}
/**
 * Данные по фонду.
 * @export
 * @interface V1EtfResponse
 */
export interface V1EtfResponse {
  /**
   *
   * @type {V1Etf}
   * @memberof V1EtfResponse
   */
  instrument?: V1Etf;
}
/**
 * Данные по фондам.
 * @export
 * @interface V1EtfsResponse
 */
export interface V1EtfsResponse {
  /**
   *
   * @type {Array<V1Etf>}
   * @memberof V1EtfsResponse
   */
  instruments?: Array<V1Etf>;
}
/**
 * Избранный инструмент.
 * @export
 * @interface V1FavoriteInstrument
 */
export interface V1FavoriteInstrument {
  /**
   *
   * @type {string}
   * @memberof V1FavoriteInstrument
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1FavoriteInstrument
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1FavoriteInstrument
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1FavoriteInstrument
   */
  isin?: string;
  /**
   *
   * @type {string}
   * @memberof V1FavoriteInstrument
   */
  instrumentType?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1FavoriteInstrument
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1FavoriteInstrument
   */
  apiTradeAvailableFlag?: boolean;
}
/**
 * Объект передачи информации о фьючерсе.
 * @export
 * @interface V1Future
 */
export interface V1Future {
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  classCode?: string;
  /**
   *
   * @type {number}
   * @memberof V1Future
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Future
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  firstTradeDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  lastTradeDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  futuresType?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  assetType?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  basicAsset?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  basicAssetSize?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  sector?: string;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  expirationDate?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Future
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Future
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Future
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Future
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Future
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Future
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Future
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Future
   */
  realExchange?: V1RealExchange;
}
/**
 * Данные по фьючерсу.
 * @export
 * @interface V1FutureResponse
 */
export interface V1FutureResponse {
  /**
   *
   * @type {V1Future}
   * @memberof V1FutureResponse
   */
  instrument?: V1Future;
}
/**
 * Данные по фьючерсам.
 * @export
 * @interface V1FuturesResponse
 */
export interface V1FuturesResponse {
  /**
   *
   * @type {Array<V1Future>}
   * @memberof V1FuturesResponse
   */
  instruments?: Array<V1Future>;
}
/**
 *
 * @export
 * @interface V1GenerateBrokerReportRequest
 */
export interface V1GenerateBrokerReportRequest {
  /**
   *
   * @type {string}
   * @memberof V1GenerateBrokerReportRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1GenerateBrokerReportRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GenerateBrokerReportRequest
   */
  to?: string;
}
/**
 *
 * @export
 * @interface V1GenerateBrokerReportResponse
 */
export interface V1GenerateBrokerReportResponse {
  /**
   *
   * @type {string}
   * @memberof V1GenerateBrokerReportResponse
   */
  taskId?: string;
}
/**
 * Объект запроса формирования отчёта \"Справка о доходах за пределами РФ\".
 * @export
 * @interface V1GenerateDividendsForeignIssuerReportRequest
 */
export interface V1GenerateDividendsForeignIssuerReportRequest {
  /**
   *
   * @type {string}
   * @memberof V1GenerateDividendsForeignIssuerReportRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1GenerateDividendsForeignIssuerReportRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GenerateDividendsForeignIssuerReportRequest
   */
  to?: string;
}
/**
 * Объект результата задачи запуска формирования отчёта \"Справка о доходах за пределами РФ\".
 * @export
 * @interface V1GenerateDividendsForeignIssuerReportResponse
 */
export interface V1GenerateDividendsForeignIssuerReportResponse {
  /**
   *
   * @type {string}
   * @memberof V1GenerateDividendsForeignIssuerReportResponse
   */
  taskId?: string;
}
/**
 * Список счетов пользователя.
 * @export
 * @interface V1GetAccountsResponse
 */
export interface V1GetAccountsResponse {
  /**
   * Массив счетов клиента.
   * @type {Array<V1Account>}
   * @memberof V1GetAccountsResponse
   */
  accounts?: Array<V1Account>;
}
/**
 *
 * @export
 * @interface V1GetAccruedInterestsRequest
 */
export interface V1GetAccruedInterestsRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetAccruedInterestsRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetAccruedInterestsRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetAccruedInterestsRequest
   */
  to?: string;
}
/**
 *
 * @export
 * @interface V1GetAccruedInterestsResponse
 */
export interface V1GetAccruedInterestsResponse {
  /**
   *
   * @type {Array<V1AccruedInterest>}
   * @memberof V1GetAccruedInterestsResponse
   */
  accruedInterests?: Array<V1AccruedInterest>;
}
/**
 * Запрос купонов по облигации.
 * @export
 * @interface V1GetBondCouponsRequest
 */
export interface V1GetBondCouponsRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetBondCouponsRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetBondCouponsRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetBondCouponsRequest
   */
  to?: string;
}
/**
 * Купоны по облигации.
 * @export
 * @interface V1GetBondCouponsResponse
 */
export interface V1GetBondCouponsResponse {
  /**
   *
   * @type {Array<V1Coupon>}
   * @memberof V1GetBondCouponsResponse
   */
  events?: Array<V1Coupon>;
}
/**
 *
 * @export
 * @interface V1GetBrokerReportRequest
 */
export interface V1GetBrokerReportRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetBrokerReportRequest
   */
  taskId?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetBrokerReportRequest
   */
  page?: number;
}
/**
 *
 * @export
 * @interface V1GetBrokerReportResponse
 */
export interface V1GetBrokerReportResponse {
  /**
   *
   * @type {Array<V1BrokerReport>}
   * @memberof V1GetBrokerReportResponse
   */
  brokerReport?: Array<V1BrokerReport>;
  /**
   *
   * @type {number}
   * @memberof V1GetBrokerReportResponse
   */
  itemsCount?: number;
  /**
   *
   * @type {number}
   * @memberof V1GetBrokerReportResponse
   */
  pagesCount?: number;
  /**
   *
   * @type {number}
   * @memberof V1GetBrokerReportResponse
   */
  page?: number;
}
/**
 * Запрос исторических свечей.
 * @export
 * @interface V1GetCandlesRequest
 */
export interface V1GetCandlesRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetCandlesRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetCandlesRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetCandlesRequest
   */
  to?: string;
  /**
   *
   * @type {V1CandleInterval}
   * @memberof V1GetCandlesRequest
   */
  interval?: V1CandleInterval;
}
/**
 * Список свечей.
 * @export
 * @interface V1GetCandlesResponse
 */
export interface V1GetCandlesResponse {
  /**
   *
   * @type {Array<V1HistoricCandle>}
   * @memberof V1GetCandlesResponse
   */
  candles?: Array<V1HistoricCandle>;
}
/**
 * Объект запроса сформированного отчёта \"Справка о доходах за пределами РФ\".
 * @export
 * @interface V1GetDividendsForeignIssuerReportRequest
 */
export interface V1GetDividendsForeignIssuerReportRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetDividendsForeignIssuerReportRequest
   */
  taskId?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetDividendsForeignIssuerReportRequest
   */
  page?: number;
}
/**
 *
 * @export
 * @interface V1GetDividendsForeignIssuerReportResponse
 */
export interface V1GetDividendsForeignIssuerReportResponse {
  /**
   *
   * @type {Array<V1DividendsForeignIssuerReport>}
   * @memberof V1GetDividendsForeignIssuerReportResponse
   */
  dividendsForeignIssuerReport?: Array<V1DividendsForeignIssuerReport>;
  /**
   *
   * @type {number}
   * @memberof V1GetDividendsForeignIssuerReportResponse
   */
  itemsCount?: number;
  /**
   *
   * @type {number}
   * @memberof V1GetDividendsForeignIssuerReportResponse
   */
  pagesCount?: number;
  /**
   *
   * @type {number}
   * @memberof V1GetDividendsForeignIssuerReportResponse
   */
  page?: number;
}
/**
 *
 * @export
 * @interface V1GetDividendsForeignIssuerRequest
 */
export interface V1GetDividendsForeignIssuerRequest {
  /**
   *
   * @type {V1GenerateDividendsForeignIssuerReportRequest}
   * @memberof V1GetDividendsForeignIssuerRequest
   */
  generateDivForeignIssuerReport?: V1GenerateDividendsForeignIssuerReportRequest;
  /**
   *
   * @type {V1GetDividendsForeignIssuerReportRequest}
   * @memberof V1GetDividendsForeignIssuerRequest
   */
  getDivForeignIssuerReport?: V1GetDividendsForeignIssuerReportRequest;
}
/**
 *
 * @export
 * @interface V1GetDividendsForeignIssuerResponse
 */
export interface V1GetDividendsForeignIssuerResponse {
  /**
   *
   * @type {V1GenerateDividendsForeignIssuerReportResponse}
   * @memberof V1GetDividendsForeignIssuerResponse
   */
  generateDivForeignIssuerReportResponse?: V1GenerateDividendsForeignIssuerReportResponse;
  /**
   *
   * @type {V1GetDividendsForeignIssuerReportResponse}
   * @memberof V1GetDividendsForeignIssuerResponse
   */
  divForeignIssuerReport?: V1GetDividendsForeignIssuerReportResponse;
}
/**
 * Запрос дивидендов.
 * @export
 * @interface V1GetDividendsRequest
 */
export interface V1GetDividendsRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetDividendsRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetDividendsRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetDividendsRequest
   */
  to?: string;
}
/**
 * Дивиденды.
 * @export
 * @interface V1GetDividendsResponse
 */
export interface V1GetDividendsResponse {
  /**
   *
   * @type {Array<V1Dividend>}
   * @memberof V1GetDividendsResponse
   */
  dividends?: Array<V1Dividend>;
}
/**
 * Ответ избранных инструментов.
 * @export
 * @interface V1GetFavoritesResponse
 */
export interface V1GetFavoritesResponse {
  /**
   *
   * @type {Array<V1FavoriteInstrument>}
   * @memberof V1GetFavoritesResponse
   */
  favoriteInstruments?: Array<V1FavoriteInstrument>;
}
/**
 *
 * @export
 * @interface V1GetFuturesMarginRequest
 */
export interface V1GetFuturesMarginRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetFuturesMarginRequest
   */
  figi?: string;
}
/**
 *
 * @export
 * @interface V1GetFuturesMarginResponse
 */
export interface V1GetFuturesMarginResponse {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetFuturesMarginResponse
   */
  initialMarginOnBuy?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetFuturesMarginResponse
   */
  initialMarginOnSell?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetFuturesMarginResponse
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetFuturesMarginResponse
   */
  minPriceIncrementAmount?: V1Quotation;
}
/**
 * Информация о пользователе.
 * @export
 * @interface V1GetInfoResponse
 */
export interface V1GetInfoResponse {
  /**
   *
   * @type {boolean}
   * @memberof V1GetInfoResponse
   */
  premStatus?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1GetInfoResponse
   */
  qualStatus?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof V1GetInfoResponse
   */
  qualifiedForWorkWith?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof V1GetInfoResponse
   */
  tariff?: string;
}
/**
 * Запрос получения последних цен.
 * @export
 * @interface V1GetLastPricesRequest
 */
export interface V1GetLastPricesRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof V1GetLastPricesRequest
   */
  figi?: Array<string>;
}
/**
 * Список последних цен.
 * @export
 * @interface V1GetLastPricesResponse
 */
export interface V1GetLastPricesResponse {
  /**
   *
   * @type {Array<V1LastPrice>}
   * @memberof V1GetLastPricesResponse
   */
  lastPrices?: Array<V1LastPrice>;
}
/**
 * Запрос последних обезличенных сделок по инструменту.
 * @export
 * @interface V1GetLastTradesRequest
 */
export interface V1GetLastTradesRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetLastTradesRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetLastTradesRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetLastTradesRequest
   */
  to?: string;
}
/**
 * Последние обезличенные сделки по инструменту.
 * @export
 * @interface V1GetLastTradesResponse
 */
export interface V1GetLastTradesResponse {
  /**
   *
   * @type {Array<V1Trade>}
   * @memberof V1GetLastTradesResponse
   */
  trades?: Array<V1Trade>;
}
/**
 *
 * @export
 * @interface V1GetMarginAttributesRequest
 */
export interface V1GetMarginAttributesRequest {
  /**
   * Идентификатор счёта пользователя.
   * @type {string}
   * @memberof V1GetMarginAttributesRequest
   */
  accountId?: string;
}
/**
 * Маржинальные показатели по счёту.
 * @export
 * @interface V1GetMarginAttributesResponse
 */
export interface V1GetMarginAttributesResponse {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetMarginAttributesResponse
   */
  liquidPortfolio?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetMarginAttributesResponse
   */
  startingMargin?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetMarginAttributesResponse
   */
  minimalMargin?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetMarginAttributesResponse
   */
  fundsSufficiencyLevel?: V1Quotation;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1GetMarginAttributesResponse
   */
  amountOfMissingFunds?: V1MoneyValue;
}
/**
 * Запрос стакана.
 * @export
 * @interface V1GetOrderBookRequest
 */
export interface V1GetOrderBookRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetOrderBookRequest
   */
  figi?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetOrderBookRequest
   */
  depth?: number;
}
/**
 * Информация о стакане.
 * @export
 * @interface V1GetOrderBookResponse
 */
export interface V1GetOrderBookResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetOrderBookResponse
   */
  figi?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetOrderBookResponse
   */
  depth?: number;
  /**
   *
   * @type {Array<V1Order>}
   * @memberof V1GetOrderBookResponse
   */
  bids?: Array<V1Order>;
  /**
   *
   * @type {Array<V1Order>}
   * @memberof V1GetOrderBookResponse
   */
  asks?: Array<V1Order>;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetOrderBookResponse
   */
  lastPrice?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetOrderBookResponse
   */
  closePrice?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetOrderBookResponse
   */
  limitUp?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1GetOrderBookResponse
   */
  limitDown?: V1Quotation;
}
/**
 * Запрос получения статуса торгового поручения.
 * @export
 * @interface V1GetOrderStateRequest
 */
export interface V1GetOrderStateRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetOrderStateRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetOrderStateRequest
   */
  orderId?: string;
}
/**
 * Запрос получения списка активных торговых поручений.
 * @export
 * @interface V1GetOrdersRequest
 */
export interface V1GetOrdersRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetOrdersRequest
   */
  accountId?: string;
}
/**
 * Список активных торговых поручений.
 * @export
 * @interface V1GetOrdersResponse
 */
export interface V1GetOrdersResponse {
  /**
   *
   * @type {Array<V1OrderState>}
   * @memberof V1GetOrdersResponse
   */
  orders?: Array<V1OrderState>;
}
/**
 * Запрос получения списка активных стоп-заявок.
 * @export
 * @interface V1GetStopOrdersRequest
 */
export interface V1GetStopOrdersRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetStopOrdersRequest
   */
  accountId?: string;
}
/**
 * Список активных стоп-заявок.
 * @export
 * @interface V1GetStopOrdersResponse
 */
export interface V1GetStopOrdersResponse {
  /**
   *
   * @type {Array<V1StopOrder>}
   * @memberof V1GetStopOrdersResponse
   */
  stopOrders?: Array<V1StopOrder>;
}
/**
 * Запрос получения торгового статуса.
 * @export
 * @interface V1GetTradingStatusRequest
 */
export interface V1GetTradingStatusRequest {
  /**
   *
   * @type {string}
   * @memberof V1GetTradingStatusRequest
   */
  figi?: string;
}
/**
 * Информация о торговом статусе.
 * @export
 * @interface V1GetTradingStatusResponse
 */
export interface V1GetTradingStatusResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetTradingStatusResponse
   */
  figi?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1GetTradingStatusResponse
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1GetTradingStatusResponse
   */
  limitOrderAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1GetTradingStatusResponse
   */
  marketOrderAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1GetTradingStatusResponse
   */
  apiTradeAvailableFlag?: boolean;
}
/**
 * Текущие лимиты пользователя.
 * @export
 * @interface V1GetUserTariffResponse
 */
export interface V1GetUserTariffResponse {
  /**
   *
   * @type {Array<V1UnaryLimit>}
   * @memberof V1GetUserTariffResponse
   */
  unaryLimits?: Array<V1UnaryLimit>;
  /**
   *
   * @type {Array<V1StreamLimit>}
   * @memberof V1GetUserTariffResponse
   */
  streamLimits?: Array<V1StreamLimit>;
}
/**
 * Информация о свече.
 * @export
 * @interface V1HistoricCandle
 */
export interface V1HistoricCandle {
  /**
   *
   * @type {V1Quotation}
   * @memberof V1HistoricCandle
   */
  open?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1HistoricCandle
   */
  high?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1HistoricCandle
   */
  low?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1HistoricCandle
   */
  close?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1HistoricCandle
   */
  volume?: string;
  /**
   *
   * @type {string}
   * @memberof V1HistoricCandle
   */
  time?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1HistoricCandle
   */
  isComplete?: boolean;
}
/**
 * Объект передачи основной информации об инструменте.
 * @export
 * @interface V1Instrument
 */
export interface V1Instrument {
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  isin?: string;
  /**
   *
   * @type {number}
   * @memberof V1Instrument
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Instrument
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  instrumentType?: string;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Instrument
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Instrument
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Instrument
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Instrument
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Instrument
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Instrument
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Instrument
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Instrument
   */
  realExchange?: V1RealExchange;
}
/**
 *
 * @export
 * @enum {string}
 */

export const V1InstrumentIdType = {
  Unspecified: 'INSTRUMENT_ID_UNSPECIFIED',
  TypeFigi: 'INSTRUMENT_ID_TYPE_FIGI',
  TypeTicker: 'INSTRUMENT_ID_TYPE_TICKER',
  TypeUid: 'INSTRUMENT_ID_TYPE_UID',
} as const;

export type V1InstrumentIdType = typeof V1InstrumentIdType[keyof typeof V1InstrumentIdType];

/**
 * Связь с другим инструментом.
 * @export
 * @interface V1InstrumentLink
 */
export interface V1InstrumentLink {
  /**
   *
   * @type {string}
   * @memberof V1InstrumentLink
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof V1InstrumentLink
   */
  instrumentUid?: string;
}
/**
 * Запрос получения инструмента по идентификатору.
 * @export
 * @interface V1InstrumentRequest
 */
export interface V1InstrumentRequest {
  /**
   *
   * @type {V1InstrumentIdType}
   * @memberof V1InstrumentRequest
   */
  idType?: V1InstrumentIdType;
  /**
   *
   * @type {string}
   * @memberof V1InstrumentRequest
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1InstrumentRequest
   */
  id?: string;
}
/**
 * Данные по инструменту.
 * @export
 * @interface V1InstrumentResponse
 */
export interface V1InstrumentResponse {
  /**
   *
   * @type {V1Instrument}
   * @memberof V1InstrumentResponse
   */
  instrument?: V1Instrument;
}
/**
 * Статус запрашиваемых инструментов.
 * @export
 * @enum {string}
 */

export const V1InstrumentStatus = {
  Unspecified: 'INSTRUMENT_STATUS_UNSPECIFIED',
  Base: 'INSTRUMENT_STATUS_BASE',
  All: 'INSTRUMENT_STATUS_ALL',
} as const;

export type V1InstrumentStatus = typeof V1InstrumentStatus[keyof typeof V1InstrumentStatus];

/**
 * Запрос получения инструментов.
 * @export
 * @interface V1InstrumentsRequest
 */
export interface V1InstrumentsRequest {
  /**
   *
   * @type {V1InstrumentStatus}
   * @memberof V1InstrumentsRequest
   */
  instrumentStatus?: V1InstrumentStatus;
}
/**
 * Информация о цене.
 * @export
 * @interface V1LastPrice
 */
export interface V1LastPrice {
  /**
   *
   * @type {string}
   * @memberof V1LastPrice
   */
  figi?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1LastPrice
   */
  price?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1LastPrice
   */
  time?: string;
}
/**
 *
 * @export
 * @interface V1MoneyValue
 */
export interface V1MoneyValue {
  /**
   *
   * @type {string}
   * @memberof V1MoneyValue
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof V1MoneyValue
   */
  units?: string;
  /**
   *
   * @type {number}
   * @memberof V1MoneyValue
   */
  nano?: number;
}
/**
 * Номер открытого счёта в песочнице.
 * @export
 * @interface V1OpenSandboxAccountResponse
 */
export interface V1OpenSandboxAccountResponse {
  /**
   *
   * @type {string}
   * @memberof V1OpenSandboxAccountResponse
   */
  accountId?: string;
}
/**
 * Данные по операции.
 * @export
 * @interface V1Operation
 */
export interface V1Operation {
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  parentOperationId?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  currency?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Operation
   */
  payment?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Operation
   */
  price?: V1MoneyValue;
  /**
   *
   * @type {V1OperationState}
   * @memberof V1Operation
   */
  state?: V1OperationState;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  quantityRest?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  instrumentType?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof V1Operation
   */
  type?: string;
  /**
   *
   * @type {V1OperationType}
   * @memberof V1Operation
   */
  operationType?: V1OperationType;
  /**
   *
   * @type {Array<V1OperationTrade>}
   * @memberof V1Operation
   */
  trades?: Array<V1OperationTrade>;
}
/**
 * Статус запрашиваемых операций.
 * @export
 * @enum {string}
 */

export const V1OperationState = {
  Unspecified: 'OPERATION_STATE_UNSPECIFIED',
  Executed: 'OPERATION_STATE_EXECUTED',
  Canceled: 'OPERATION_STATE_CANCELED',
} as const;

export type V1OperationState = typeof V1OperationState[keyof typeof V1OperationState];

/**
 * Сделка по операции.
 * @export
 * @interface V1OperationTrade
 */
export interface V1OperationTrade {
  /**
   *
   * @type {string}
   * @memberof V1OperationTrade
   */
  tradeId?: string;
  /**
   *
   * @type {string}
   * @memberof V1OperationTrade
   */
  dateTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1OperationTrade
   */
  quantity?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OperationTrade
   */
  price?: V1MoneyValue;
}
/**
 * Тип операции.
 * @export
 * @enum {string}
 */

export const V1OperationType = {
  Unspecified: 'OPERATION_TYPE_UNSPECIFIED',
  Input: 'OPERATION_TYPE_INPUT',
  BondTax: 'OPERATION_TYPE_BOND_TAX',
  OutputSecurities: 'OPERATION_TYPE_OUTPUT_SECURITIES',
  Overnight: 'OPERATION_TYPE_OVERNIGHT',
  Tax: 'OPERATION_TYPE_TAX',
  BondRepaymentFull: 'OPERATION_TYPE_BOND_REPAYMENT_FULL',
  SellCard: 'OPERATION_TYPE_SELL_CARD',
  DividendTax: 'OPERATION_TYPE_DIVIDEND_TAX',
  Output: 'OPERATION_TYPE_OUTPUT',
  BondRepayment: 'OPERATION_TYPE_BOND_REPAYMENT',
  TaxCorrection: 'OPERATION_TYPE_TAX_CORRECTION',
  ServiceFee: 'OPERATION_TYPE_SERVICE_FEE',
  BenefitTax: 'OPERATION_TYPE_BENEFIT_TAX',
  MarginFee: 'OPERATION_TYPE_MARGIN_FEE',
  Buy: 'OPERATION_TYPE_BUY',
  BuyCard: 'OPERATION_TYPE_BUY_CARD',
  InputSecurities: 'OPERATION_TYPE_INPUT_SECURITIES',
  SellMargin: 'OPERATION_TYPE_SELL_MARGIN',
  BrokerFee: 'OPERATION_TYPE_BROKER_FEE',
  BuyMargin: 'OPERATION_TYPE_BUY_MARGIN',
  Dividend: 'OPERATION_TYPE_DIVIDEND',
  Sell: 'OPERATION_TYPE_SELL',
  Coupon: 'OPERATION_TYPE_COUPON',
  SuccessFee: 'OPERATION_TYPE_SUCCESS_FEE',
  DividendTransfer: 'OPERATION_TYPE_DIVIDEND_TRANSFER',
  AccruingVarmargin: 'OPERATION_TYPE_ACCRUING_VARMARGIN',
  WritingOffVarmargin: 'OPERATION_TYPE_WRITING_OFF_VARMARGIN',
  DeliveryBuy: 'OPERATION_TYPE_DELIVERY_BUY',
  DeliverySell: 'OPERATION_TYPE_DELIVERY_SELL',
  TrackMfee: 'OPERATION_TYPE_TRACK_MFEE',
  TrackPfee: 'OPERATION_TYPE_TRACK_PFEE',
  TaxProgressive: 'OPERATION_TYPE_TAX_PROGRESSIVE',
  BondTaxProgressive: 'OPERATION_TYPE_BOND_TAX_PROGRESSIVE',
  DividendTaxProgressive: 'OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE',
  BenefitTaxProgressive: 'OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE',
  TaxCorrectionProgressive: 'OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE',
  TaxRepoProgressive: 'OPERATION_TYPE_TAX_REPO_PROGRESSIVE',
  TaxRepo: 'OPERATION_TYPE_TAX_REPO',
  TaxRepoHold: 'OPERATION_TYPE_TAX_REPO_HOLD',
  TaxRepoRefund: 'OPERATION_TYPE_TAX_REPO_REFUND',
  TaxRepoHoldProgressive: 'OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE',
  TaxRepoRefundProgressive: 'OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE',
  DivExt: 'OPERATION_TYPE_DIV_EXT',
  TaxCorrectionCoupon: 'OPERATION_TYPE_TAX_CORRECTION_COUPON',
} as const;

export type V1OperationType = typeof V1OperationType[keyof typeof V1OperationType];

/**
 * Запрос получения списка операций по счёту.
 * @export
 * @interface V1OperationsRequest
 */
export interface V1OperationsRequest {
  /**
   *
   * @type {string}
   * @memberof V1OperationsRequest
   */
  accountId?: string;
  /**
   *
   * @type {string}
   * @memberof V1OperationsRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1OperationsRequest
   */
  to?: string;
  /**
   *
   * @type {V1OperationState}
   * @memberof V1OperationsRequest
   */
  state?: V1OperationState;
  /**
   *
   * @type {string}
   * @memberof V1OperationsRequest
   */
  figi?: string;
}
/**
 * Список операций.
 * @export
 * @interface V1OperationsResponse
 */
export interface V1OperationsResponse {
  /**
   *
   * @type {Array<V1Operation>}
   * @memberof V1OperationsResponse
   */
  operations?: Array<V1Operation>;
}
/**
 * Массив предложений/спроса.
 * @export
 * @interface V1Order
 */
export interface V1Order {
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Order
   */
  price?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Order
   */
  quantity?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const V1OrderDirection = {
  Unspecified: 'ORDER_DIRECTION_UNSPECIFIED',
  Buy: 'ORDER_DIRECTION_BUY',
  Sell: 'ORDER_DIRECTION_SELL',
} as const;

export type V1OrderDirection = typeof V1OrderDirection[keyof typeof V1OrderDirection];

/**
 *
 * @export
 * @enum {string}
 */

export const V1OrderExecutionReportStatus = {
  Unspecified: 'EXECUTION_REPORT_STATUS_UNSPECIFIED',
  Fill: 'EXECUTION_REPORT_STATUS_FILL',
  Rejected: 'EXECUTION_REPORT_STATUS_REJECTED',
  Cancelled: 'EXECUTION_REPORT_STATUS_CANCELLED',
  New: 'EXECUTION_REPORT_STATUS_NEW',
  Partiallyfill: 'EXECUTION_REPORT_STATUS_PARTIALLYFILL',
} as const;

export type V1OrderExecutionReportStatus =
  typeof V1OrderExecutionReportStatus[keyof typeof V1OrderExecutionReportStatus];

/**
 * Сделки в рамках торгового поручения.
 * @export
 * @interface V1OrderStage
 */
export interface V1OrderStage {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderStage
   */
  price?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1OrderStage
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof V1OrderStage
   */
  tradeId?: string;
}
/**
 * Информация о торговом поручении.
 * @export
 * @interface V1OrderState
 */
export interface V1OrderState {
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  orderId?: string;
  /**
   *
   * @type {V1OrderExecutionReportStatus}
   * @memberof V1OrderState
   */
  executionReportStatus?: V1OrderExecutionReportStatus;
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  lotsRequested?: string;
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  lotsExecuted?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  initialOrderPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  executedOrderPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  totalOrderAmount?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  averagePositionPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  initialCommission?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  executedCommission?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  figi?: string;
  /**
   *
   * @type {V1OrderDirection}
   * @memberof V1OrderState
   */
  direction?: V1OrderDirection;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  initialSecurityPrice?: V1MoneyValue;
  /**
   *
   * @type {Array<V1OrderStage>}
   * @memberof V1OrderState
   */
  stages?: Array<V1OrderStage>;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1OrderState
   */
  serviceCommission?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  currency?: string;
  /**
   *
   * @type {V1OrderType}
   * @memberof V1OrderState
   */
  orderType?: V1OrderType;
  /**
   *
   * @type {string}
   * @memberof V1OrderState
   */
  orderDate?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const V1OrderType = {
  Unspecified: 'ORDER_TYPE_UNSPECIFIED',
  Limit: 'ORDER_TYPE_LIMIT',
  Market: 'ORDER_TYPE_MARKET',
} as const;

export type V1OrderType = typeof V1OrderType[keyof typeof V1OrderType];

/**
 * Позиции портфеля.
 * @export
 * @interface V1PortfolioPosition
 */
export interface V1PortfolioPosition {
  /**
   *
   * @type {string}
   * @memberof V1PortfolioPosition
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1PortfolioPosition
   */
  instrumentType?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PortfolioPosition
   */
  quantity?: V1Quotation;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioPosition
   */
  averagePositionPrice?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PortfolioPosition
   */
  expectedYield?: V1Quotation;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioPosition
   */
  currentNkd?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PortfolioPosition
   */
  averagePositionPricePt?: V1Quotation;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioPosition
   */
  currentPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioPosition
   */
  averagePositionPriceFifo?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PortfolioPosition
   */
  quantityLots?: V1Quotation;
}
/**
 * Запрос получения текущего портфеля по счёту.
 * @export
 * @interface V1PortfolioRequest
 */
export interface V1PortfolioRequest {
  /**
   *
   * @type {string}
   * @memberof V1PortfolioRequest
   */
  accountId?: string;
}
/**
 * Текущий портфель по счёту.
 * @export
 * @interface V1PortfolioResponse
 */
export interface V1PortfolioResponse {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioResponse
   */
  totalAmountShares?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioResponse
   */
  totalAmountBonds?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioResponse
   */
  totalAmountEtf?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioResponse
   */
  totalAmountCurrencies?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PortfolioResponse
   */
  totalAmountFutures?: V1MoneyValue;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PortfolioResponse
   */
  expectedYield?: V1Quotation;
  /**
   *
   * @type {Array<V1PortfolioPosition>}
   * @memberof V1PortfolioResponse
   */
  positions?: Array<V1PortfolioPosition>;
}
/**
 * Баланс фьючерса.
 * @export
 * @interface V1PositionsFutures
 */
export interface V1PositionsFutures {
  /**
   *
   * @type {string}
   * @memberof V1PositionsFutures
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1PositionsFutures
   */
  blocked?: string;
  /**
   *
   * @type {string}
   * @memberof V1PositionsFutures
   */
  balance?: string;
}
/**
 * Запрос позиций портфеля по счёту.
 * @export
 * @interface V1PositionsRequest
 */
export interface V1PositionsRequest {
  /**
   *
   * @type {string}
   * @memberof V1PositionsRequest
   */
  accountId?: string;
}
/**
 * Список позиций по счёту.
 * @export
 * @interface V1PositionsResponse
 */
export interface V1PositionsResponse {
  /**
   *
   * @type {Array<V1MoneyValue>}
   * @memberof V1PositionsResponse
   */
  money?: Array<V1MoneyValue>;
  /**
   *
   * @type {Array<V1MoneyValue>}
   * @memberof V1PositionsResponse
   */
  blocked?: Array<V1MoneyValue>;
  /**
   *
   * @type {Array<V1PositionsSecurities>}
   * @memberof V1PositionsResponse
   */
  securities?: Array<V1PositionsSecurities>;
  /**
   *
   * @type {boolean}
   * @memberof V1PositionsResponse
   */
  limitsLoadingInProgress?: boolean;
  /**
   *
   * @type {Array<V1PositionsFutures>}
   * @memberof V1PositionsResponse
   */
  futures?: Array<V1PositionsFutures>;
}
/**
 * Баланс позиции ценной бумаги.
 * @export
 * @interface V1PositionsSecurities
 */
export interface V1PositionsSecurities {
  /**
   *
   * @type {string}
   * @memberof V1PositionsSecurities
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1PositionsSecurities
   */
  blocked?: string;
  /**
   *
   * @type {string}
   * @memberof V1PositionsSecurities
   */
  balance?: string;
}
/**
 * Запрос выставления торгового поручения.
 * @export
 * @interface V1PostOrderRequest
 */
export interface V1PostOrderRequest {
  /**
   *
   * @type {string}
   * @memberof V1PostOrderRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderRequest
   */
  quantity?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PostOrderRequest
   */
  price?: V1Quotation;
  /**
   *
   * @type {V1OrderDirection}
   * @memberof V1PostOrderRequest
   */
  direction?: V1OrderDirection;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderRequest
   */
  accountId?: string;
  /**
   *
   * @type {V1OrderType}
   * @memberof V1PostOrderRequest
   */
  orderType?: V1OrderType;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderRequest
   */
  orderId?: string;
}
/**
 * Информация о выставлении поручения.
 * @export
 * @interface V1PostOrderResponse
 */
export interface V1PostOrderResponse {
  /**
   *
   * @type {string}
   * @memberof V1PostOrderResponse
   */
  orderId?: string;
  /**
   *
   * @type {V1OrderExecutionReportStatus}
   * @memberof V1PostOrderResponse
   */
  executionReportStatus?: V1OrderExecutionReportStatus;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderResponse
   */
  lotsRequested?: string;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderResponse
   */
  lotsExecuted?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  initialOrderPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  executedOrderPrice?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  totalOrderAmount?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  initialCommission?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  executedCommission?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  aciValue?: V1MoneyValue;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderResponse
   */
  figi?: string;
  /**
   *
   * @type {V1OrderDirection}
   * @memberof V1PostOrderResponse
   */
  direction?: V1OrderDirection;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1PostOrderResponse
   */
  initialSecurityPrice?: V1MoneyValue;
  /**
   *
   * @type {V1OrderType}
   * @memberof V1PostOrderResponse
   */
  orderType?: V1OrderType;
  /**
   *
   * @type {string}
   * @memberof V1PostOrderResponse
   */
  message?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PostOrderResponse
   */
  initialOrderPricePt?: V1Quotation;
}
/**
 * Запрос выставления стоп-заявки.
 * @export
 * @interface V1PostStopOrderRequest
 */
export interface V1PostStopOrderRequest {
  /**
   *
   * @type {string}
   * @memberof V1PostStopOrderRequest
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1PostStopOrderRequest
   */
  quantity?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PostStopOrderRequest
   */
  price?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1PostStopOrderRequest
   */
  stopPrice?: V1Quotation;
  /**
   *
   * @type {V1StopOrderDirection}
   * @memberof V1PostStopOrderRequest
   */
  direction?: V1StopOrderDirection;
  /**
   *
   * @type {string}
   * @memberof V1PostStopOrderRequest
   */
  accountId?: string;
  /**
   *
   * @type {V1StopOrderExpirationType}
   * @memberof V1PostStopOrderRequest
   */
  expirationType?: V1StopOrderExpirationType;
  /**
   *
   * @type {V1StopOrderType}
   * @memberof V1PostStopOrderRequest
   */
  stopOrderType?: V1StopOrderType;
  /**
   *
   * @type {string}
   * @memberof V1PostStopOrderRequest
   */
  expireDate?: string;
}
/**
 * Результат выставления стоп-заявки.
 * @export
 * @interface V1PostStopOrderResponse
 */
export interface V1PostStopOrderResponse {
  /**
   *
   * @type {string}
   * @memberof V1PostStopOrderResponse
   */
  stopOrderId?: string;
}
/**
 *
 * @export
 * @interface V1Quotation
 */
export interface V1Quotation {
  /**
   *
   * @type {string}
   * @memberof V1Quotation
   */
  units?: string;
  /**
   *
   * @type {number}
   * @memberof V1Quotation
   */
  nano?: number;
}
/**
 * Реальная площадка исполнения расчётов.
 * @export
 * @enum {string}
 */

export const V1RealExchange = {
  Unspecified: 'REAL_EXCHANGE_UNSPECIFIED',
  Moex: 'REAL_EXCHANGE_MOEX',
  Rts: 'REAL_EXCHANGE_RTS',
  Otc: 'REAL_EXCHANGE_OTC',
} as const;

export type V1RealExchange = typeof V1RealExchange[keyof typeof V1RealExchange];

/**
 * Запрос пополнения счёта в песочнице.
 * @export
 * @interface V1SandboxPayInRequest
 */
export interface V1SandboxPayInRequest {
  /**
   *
   * @type {string}
   * @memberof V1SandboxPayInRequest
   */
  accountId?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1SandboxPayInRequest
   */
  amount?: V1MoneyValue;
}
/**
 * Результат пополнения счёта, текущий баланс.
 * @export
 * @interface V1SandboxPayInResponse
 */
export interface V1SandboxPayInResponse {
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1SandboxPayInResponse
   */
  balance?: V1MoneyValue;
}
/**
 *
 * @export
 * @enum {string}
 */

export const V1SecurityTradingStatus = {
  Unspecified: 'SECURITY_TRADING_STATUS_UNSPECIFIED',
  NotAvailableForTrading: 'SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING',
  OpeningPeriod: 'SECURITY_TRADING_STATUS_OPENING_PERIOD',
  ClosingPeriod: 'SECURITY_TRADING_STATUS_CLOSING_PERIOD',
  BreakInTrading: 'SECURITY_TRADING_STATUS_BREAK_IN_TRADING',
  NormalTrading: 'SECURITY_TRADING_STATUS_NORMAL_TRADING',
  ClosingAuction: 'SECURITY_TRADING_STATUS_CLOSING_AUCTION',
  DarkPoolAuction: 'SECURITY_TRADING_STATUS_DARK_POOL_AUCTION',
  DiscreteAuction: 'SECURITY_TRADING_STATUS_DISCRETE_AUCTION',
  OpeningAuctionPeriod: 'SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD',
  TradingAtClosingAuctionPrice: 'SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE',
  SessionAssigned: 'SECURITY_TRADING_STATUS_SESSION_ASSIGNED',
  SessionClose: 'SECURITY_TRADING_STATUS_SESSION_CLOSE',
  SessionOpen: 'SECURITY_TRADING_STATUS_SESSION_OPEN',
  DealerNormalTrading: 'SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING',
  DealerBreakInTrading: 'SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING',
  DealerNotAvailableForTrading: 'SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING',
} as const;

export type V1SecurityTradingStatus =
  typeof V1SecurityTradingStatus[keyof typeof V1SecurityTradingStatus];

/**
 * Объект передачи информации об акции.
 * @export
 * @interface V1Share
 */
export interface V1Share {
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  figi?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  ticker?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  isin?: string;
  /**
   *
   * @type {number}
   * @memberof V1Share
   */
  lot?: number;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  currency?: string;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  klong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  kshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  dlong?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  dshort?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  dlongMin?: V1Quotation;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  dshortMin?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  shortEnabledFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  ipoDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  issueSize?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  countryOfRisk?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  countryOfRiskName?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  sector?: string;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  issueSizePlan?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1Share
   */
  nominal?: V1MoneyValue;
  /**
   *
   * @type {V1SecurityTradingStatus}
   * @memberof V1Share
   */
  tradingStatus?: V1SecurityTradingStatus;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  otcFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  buyAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  sellAvailableFlag?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  divYieldFlag?: boolean;
  /**
   *
   * @type {V1ShareType}
   * @memberof V1Share
   */
  shareType?: V1ShareType;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Share
   */
  minPriceIncrement?: V1Quotation;
  /**
   *
   * @type {boolean}
   * @memberof V1Share
   */
  apiTradeAvailableFlag?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Share
   */
  uid?: string;
  /**
   *
   * @type {V1RealExchange}
   * @memberof V1Share
   */
  realExchange?: V1RealExchange;
}
/**
 * Данные по акции.
 * @export
 * @interface V1ShareResponse
 */
export interface V1ShareResponse {
  /**
   *
   * @type {V1Share}
   * @memberof V1ShareResponse
   */
  instrument?: V1Share;
}
/**
 * Тип акций.
 * @export
 * @enum {string}
 */

export const V1ShareType = {
  Unspecified: 'SHARE_TYPE_UNSPECIFIED',
  Common: 'SHARE_TYPE_COMMON',
  Preferred: 'SHARE_TYPE_PREFERRED',
  Adr: 'SHARE_TYPE_ADR',
  Gdr: 'SHARE_TYPE_GDR',
  Mlp: 'SHARE_TYPE_MLP',
  NyRegShrs: 'SHARE_TYPE_NY_REG_SHRS',
  ClosedEndFund: 'SHARE_TYPE_CLOSED_END_FUND',
  Reit: 'SHARE_TYPE_REIT',
} as const;

export type V1ShareType = typeof V1ShareType[keyof typeof V1ShareType];

/**
 * Данные по акциям.
 * @export
 * @interface V1SharesResponse
 */
export interface V1SharesResponse {
  /**
   *
   * @type {Array<V1Share>}
   * @memberof V1SharesResponse
   */
  instruments?: Array<V1Share>;
}
/**
 * Информация о стоп-заявке.
 * @export
 * @interface V1StopOrder
 */
export interface V1StopOrder {
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  stopOrderId?: string;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  lotsRequested?: string;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  figi?: string;
  /**
   *
   * @type {V1StopOrderDirection}
   * @memberof V1StopOrder
   */
  direction?: V1StopOrderDirection;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  currency?: string;
  /**
   *
   * @type {V1StopOrderType}
   * @memberof V1StopOrder
   */
  orderType?: V1StopOrderType;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  createDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  activationDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1StopOrder
   */
  expirationTime?: string;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1StopOrder
   */
  price?: V1MoneyValue;
  /**
   *
   * @type {V1MoneyValue}
   * @memberof V1StopOrder
   */
  stopPrice?: V1MoneyValue;
}
/**
 * Направление сделки стоп-заявки.
 * @export
 * @enum {string}
 */

export const V1StopOrderDirection = {
  Unspecified: 'STOP_ORDER_DIRECTION_UNSPECIFIED',
  Buy: 'STOP_ORDER_DIRECTION_BUY',
  Sell: 'STOP_ORDER_DIRECTION_SELL',
} as const;

export type V1StopOrderDirection = typeof V1StopOrderDirection[keyof typeof V1StopOrderDirection];

/**
 * Тип экспирации стоп-заявке.
 * @export
 * @enum {string}
 */

export const V1StopOrderExpirationType = {
  Unspecified: 'STOP_ORDER_EXPIRATION_TYPE_UNSPECIFIED',
  GoodTillCancel: 'STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL',
  GoodTillDate: 'STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_DATE',
} as const;

export type V1StopOrderExpirationType =
  typeof V1StopOrderExpirationType[keyof typeof V1StopOrderExpirationType];

/**
 * Тип стоп-заявки.
 * @export
 * @enum {string}
 */

export const V1StopOrderType = {
  Unspecified: 'STOP_ORDER_TYPE_UNSPECIFIED',
  TakeProfit: 'STOP_ORDER_TYPE_TAKE_PROFIT',
  StopLoss: 'STOP_ORDER_TYPE_STOP_LOSS',
  StopLimit: 'STOP_ORDER_TYPE_STOP_LIMIT',
} as const;

export type V1StopOrderType = typeof V1StopOrderType[keyof typeof V1StopOrderType];

/**
 * Лимит stream-соединений.
 * @export
 * @interface V1StreamLimit
 */
export interface V1StreamLimit {
  /**
   *
   * @type {number}
   * @memberof V1StreamLimit
   */
  limit?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof V1StreamLimit
   */
  streams?: Array<string>;
}
/**
 * Тип структурной ноты.
 * @export
 * @enum {string}
 */

export const V1StructuredProductType = {
  Unspecified: 'SP_TYPE_UNSPECIFIED',
  Deliverable: 'SP_TYPE_DELIVERABLE',
  NonDeliverable: 'SP_TYPE_NON_DELIVERABLE',
} as const;

export type V1StructuredProductType =
  typeof V1StructuredProductType[keyof typeof V1StructuredProductType];

/**
 * Информация о сделке.
 * @export
 * @interface V1Trade
 */
export interface V1Trade {
  /**
   *
   * @type {string}
   * @memberof V1Trade
   */
  figi?: string;
  /**
   *
   * @type {V1TradeDirection}
   * @memberof V1Trade
   */
  direction?: V1TradeDirection;
  /**
   *
   * @type {V1Quotation}
   * @memberof V1Trade
   */
  price?: V1Quotation;
  /**
   *
   * @type {string}
   * @memberof V1Trade
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof V1Trade
   */
  time?: string;
}
/**
 * Направление сделки.
 * @export
 * @enum {string}
 */

export const V1TradeDirection = {
  Unspecified: 'TRADE_DIRECTION_UNSPECIFIED',
  Buy: 'TRADE_DIRECTION_BUY',
  Sell: 'TRADE_DIRECTION_SELL',
} as const;

export type V1TradeDirection = typeof V1TradeDirection[keyof typeof V1TradeDirection];

/**
 * Информация о времени торгов.
 * @export
 * @interface V1TradingDay
 */
export interface V1TradingDay {
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  date?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1TradingDay
   */
  isTradingDay?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  endTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  openingAuctionStartTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  closingAuctionEndTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  eveningOpeningAuctionStartTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  eveningStartTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  eveningEndTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  clearingStartTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  clearingEndTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  premarketStartTime?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingDay
   */
  premarketEndTime?: string;
}
/**
 * Данные по торговой площадке.
 * @export
 * @interface V1TradingSchedule
 */
export interface V1TradingSchedule {
  /**
   *
   * @type {string}
   * @memberof V1TradingSchedule
   */
  exchange?: string;
  /**
   *
   * @type {Array<V1TradingDay>}
   * @memberof V1TradingSchedule
   */
  days?: Array<V1TradingDay>;
}
/**
 *
 * @export
 * @interface V1TradingSchedulesRequest
 */
export interface V1TradingSchedulesRequest {
  /**
   *
   * @type {string}
   * @memberof V1TradingSchedulesRequest
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingSchedulesRequest
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof V1TradingSchedulesRequest
   */
  to?: string;
}
/**
 *
 * @export
 * @interface V1TradingSchedulesResponse
 */
export interface V1TradingSchedulesResponse {
  /**
   *
   * @type {Array<V1TradingSchedule>}
   * @memberof V1TradingSchedulesResponse
   */
  exchanges?: Array<V1TradingSchedule>;
}
/**
 * Лимит unary-методов.
 * @export
 * @interface V1UnaryLimit
 */
export interface V1UnaryLimit {
  /**
   *
   * @type {number}
   * @memberof V1UnaryLimit
   */
  limitPerMinute?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof V1UnaryLimit
   */
  methods?: Array<string>;
}
/**
 * Запрос доступного для вывода остатка.
 * @export
 * @interface V1WithdrawLimitsRequest
 */
export interface V1WithdrawLimitsRequest {
  /**
   *
   * @type {string}
   * @memberof V1WithdrawLimitsRequest
   */
  accountId?: string;
}
/**
 * Доступный для вывода остаток.
 * @export
 * @interface V1WithdrawLimitsResponse
 */
export interface V1WithdrawLimitsResponse {
  /**
   *
   * @type {Array<V1MoneyValue>}
   * @memberof V1WithdrawLimitsResponse
   */
  money?: Array<V1MoneyValue>;
  /**
   *
   * @type {Array<V1MoneyValue>}
   * @memberof V1WithdrawLimitsResponse
   */
  blocked?: Array<V1MoneyValue>;
  /**
   *
   * @type {Array<V1MoneyValue>}
   * @memberof V1WithdrawLimitsResponse
   */
  blockedGuarantee?: Array<V1MoneyValue>;
}

/**
 * InstrumentsServiceApi - axios parameter creator
 * @export
 */
export const InstrumentsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод получения облигации по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceBondBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceBondBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/BondBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка облигаций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceBonds: async (
      body: V1InstrumentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceBonds', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/Bonds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка валют.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceCurrencies: async (
      body: V1InstrumentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceCurrencies', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/Currencies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения валюты по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceCurrencyBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceCurrencyBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/CurrencyBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод редактирования избранных инструментов.
     * @param {V1EditFavoritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEditFavorites: async (
      body: V1EditFavoritesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceEditFavorites', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/EditFavorites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения инвестиционного фонда по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEtfBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceEtfBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/EtfBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка инвестиционных фондов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEtfs: async (
      body: V1InstrumentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceEtfs', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/Etfs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения фьючерса по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceFutureBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceFutureBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/FutureBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка фьючерсов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceFutures: async (
      body: V1InstrumentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceFutures', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/Futures`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения накопленного купонного дохода по облигации.
     * @param {V1GetAccruedInterestsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAccruedInterests: async (
      body: V1GetAccruedInterestsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetAccruedInterests', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAccruedInterests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения актива по его идентификатору.
     * @param {V1AssetRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAssetBy: async (
      body: V1AssetRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetAssetBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка активов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAssets: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetAssets', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения графика выплат купонов по облигации
     * @param {V1GetBondCouponsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetBondCoupons: async (
      body: V1GetBondCouponsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetBondCoupons', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBondCoupons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод для получения событий выплаты дивидендов по инструменту.
     * @param {V1GetDividendsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetDividends: async (
      body: V1GetDividendsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetDividends', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetDividends`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения избранных инструментов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetFavorites: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetFavorites', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFavorites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения размера гарантийного обеспечения по фьючерсам.
     * @param {V1GetFuturesMarginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetFuturesMargin: async (
      body: V1GetFuturesMarginRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetFuturesMargin', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFuturesMargin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения основной информации об инструменте.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetInstrumentBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceGetInstrumentBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetInstrumentBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения акции по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceShareBy: async (
      body: V1InstrumentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceShareBy', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/ShareBy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка акций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceShares: async (
      body: V1InstrumentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceShares', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/Shares`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения расписания торгов торговых площадок.
     * @param {V1TradingSchedulesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceTradingSchedules: async (
      body: V1TradingSchedulesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('instrumentsServiceTradingSchedules', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.InstrumentsService/TradingSchedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentsServiceApi - functional programming interface
 * @export
 */
export const InstrumentsServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InstrumentsServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод получения облигации по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceBondBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BondResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceBondBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка облигаций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceBonds(
      body: V1InstrumentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BondsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceBonds(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка валют.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceCurrencies(
      body: V1InstrumentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CurrenciesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceCurrencies(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения валюты по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceCurrencyBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CurrencyResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceCurrencyBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод редактирования избранных инструментов.
     * @param {V1EditFavoritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceEditFavorites(
      body: V1EditFavoritesRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EditFavoritesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceEditFavorites(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения инвестиционного фонда по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceEtfBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EtfResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceEtfBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка инвестиционных фондов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceEtfs(
      body: V1InstrumentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1EtfsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceEtfs(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения фьючерса по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceFutureBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FutureResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceFutureBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка фьючерсов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceFutures(
      body: V1InstrumentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FuturesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceFutures(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения накопленного купонного дохода по облигации.
     * @param {V1GetAccruedInterestsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetAccruedInterests(
      body: V1GetAccruedInterestsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccruedInterestsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.instrumentsServiceGetAccruedInterests(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения актива по его идентификатору.
     * @param {V1AssetRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetAssetBy(
      body: V1AssetRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AssetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetAssetBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка активов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetAssets(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AssetsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetAssets(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения графика выплат купонов по облигации
     * @param {V1GetBondCouponsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetBondCoupons(
      body: V1GetBondCouponsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetBondCouponsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetBondCoupons(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод для получения событий выплаты дивидендов по инструменту.
     * @param {V1GetDividendsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetDividends(
      body: V1GetDividendsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetDividendsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetDividends(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения избранных инструментов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetFavorites(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetFavoritesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetFavorites(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения размера гарантийного обеспечения по фьючерсам.
     * @param {V1GetFuturesMarginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetFuturesMargin(
      body: V1GetFuturesMarginRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetFuturesMarginResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetFuturesMargin(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения основной информации об инструменте.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceGetInstrumentBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InstrumentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceGetInstrumentBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения акции по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceShareBy(
      body: V1InstrumentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ShareResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceShareBy(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка акций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceShares(
      body: V1InstrumentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1SharesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceShares(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения расписания торгов торговых площадок.
     * @param {V1TradingSchedulesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async instrumentsServiceTradingSchedules(
      body: V1TradingSchedulesRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1TradingSchedulesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.instrumentsServiceTradingSchedules(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * InstrumentsServiceApi - factory interface
 * @export
 */
export const InstrumentsServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = InstrumentsServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод получения облигации по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceBondBy(
      body: V1InstrumentRequest,
      options?: any,
    ): AxiosPromise<V1BondResponse> {
      return localVarFp
        .instrumentsServiceBondBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка облигаций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceBonds(
      body: V1InstrumentsRequest,
      options?: any,
    ): AxiosPromise<V1BondsResponse> {
      return localVarFp
        .instrumentsServiceBonds(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка валют.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceCurrencies(
      body: V1InstrumentsRequest,
      options?: any,
    ): AxiosPromise<V1CurrenciesResponse> {
      return localVarFp
        .instrumentsServiceCurrencies(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения валюты по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceCurrencyBy(
      body: V1InstrumentRequest,
      options?: any,
    ): AxiosPromise<V1CurrencyResponse> {
      return localVarFp
        .instrumentsServiceCurrencyBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод редактирования избранных инструментов.
     * @param {V1EditFavoritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEditFavorites(
      body: V1EditFavoritesRequest,
      options?: any,
    ): AxiosPromise<V1EditFavoritesResponse> {
      return localVarFp
        .instrumentsServiceEditFavorites(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения инвестиционного фонда по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEtfBy(body: V1InstrumentRequest, options?: any): AxiosPromise<V1EtfResponse> {
      return localVarFp
        .instrumentsServiceEtfBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка инвестиционных фондов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceEtfs(
      body: V1InstrumentsRequest,
      options?: any,
    ): AxiosPromise<V1EtfsResponse> {
      return localVarFp
        .instrumentsServiceEtfs(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения фьючерса по его идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceFutureBy(
      body: V1InstrumentRequest,
      options?: any,
    ): AxiosPromise<V1FutureResponse> {
      return localVarFp
        .instrumentsServiceFutureBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка фьючерсов.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceFutures(
      body: V1InstrumentsRequest,
      options?: any,
    ): AxiosPromise<V1FuturesResponse> {
      return localVarFp
        .instrumentsServiceFutures(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения накопленного купонного дохода по облигации.
     * @param {V1GetAccruedInterestsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAccruedInterests(
      body: V1GetAccruedInterestsRequest,
      options?: any,
    ): AxiosPromise<V1GetAccruedInterestsResponse> {
      return localVarFp
        .instrumentsServiceGetAccruedInterests(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения актива по его идентификатору.
     * @param {V1AssetRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAssetBy(
      body: V1AssetRequest,
      options?: any,
    ): AxiosPromise<V1AssetResponse> {
      return localVarFp
        .instrumentsServiceGetAssetBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка активов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetAssets(body: object, options?: any): AxiosPromise<V1AssetsResponse> {
      return localVarFp
        .instrumentsServiceGetAssets(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения графика выплат купонов по облигации
     * @param {V1GetBondCouponsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetBondCoupons(
      body: V1GetBondCouponsRequest,
      options?: any,
    ): AxiosPromise<V1GetBondCouponsResponse> {
      return localVarFp
        .instrumentsServiceGetBondCoupons(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод для получения событий выплаты дивидендов по инструменту.
     * @param {V1GetDividendsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetDividends(
      body: V1GetDividendsRequest,
      options?: any,
    ): AxiosPromise<V1GetDividendsResponse> {
      return localVarFp
        .instrumentsServiceGetDividends(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения избранных инструментов.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetFavorites(
      body: object,
      options?: any,
    ): AxiosPromise<V1GetFavoritesResponse> {
      return localVarFp
        .instrumentsServiceGetFavorites(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения размера гарантийного обеспечения по фьючерсам.
     * @param {V1GetFuturesMarginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetFuturesMargin(
      body: V1GetFuturesMarginRequest,
      options?: any,
    ): AxiosPromise<V1GetFuturesMarginResponse> {
      return localVarFp
        .instrumentsServiceGetFuturesMargin(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения основной информации об инструменте.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceGetInstrumentBy(
      body: V1InstrumentRequest,
      options?: any,
    ): AxiosPromise<V1InstrumentResponse> {
      return localVarFp
        .instrumentsServiceGetInstrumentBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения акции по её идентификатору.
     * @param {V1InstrumentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceShareBy(
      body: V1InstrumentRequest,
      options?: any,
    ): AxiosPromise<V1ShareResponse> {
      return localVarFp
        .instrumentsServiceShareBy(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка акций.
     * @param {V1InstrumentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceShares(
      body: V1InstrumentsRequest,
      options?: any,
    ): AxiosPromise<V1SharesResponse> {
      return localVarFp
        .instrumentsServiceShares(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения расписания торгов торговых площадок.
     * @param {V1TradingSchedulesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentsServiceTradingSchedules(
      body: V1TradingSchedulesRequest,
      options?: any,
    ): AxiosPromise<V1TradingSchedulesResponse> {
      return localVarFp
        .instrumentsServiceTradingSchedules(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for instrumentsServiceBondBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceBondByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceBondByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceBondBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceBonds operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceBondsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceBondsRequest {
  /**
   *
   * @type {V1InstrumentsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceBonds
   */
  readonly body: V1InstrumentsRequest;
}

/**
 * Request parameters for instrumentsServiceCurrencies operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceCurrenciesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceCurrenciesRequest {
  /**
   *
   * @type {V1InstrumentsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceCurrencies
   */
  readonly body: V1InstrumentsRequest;
}

/**
 * Request parameters for instrumentsServiceCurrencyBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceCurrencyByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceCurrencyByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceCurrencyBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceEditFavorites operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceEditFavoritesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceEditFavoritesRequest {
  /**
   *
   * @type {V1EditFavoritesRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceEditFavorites
   */
  readonly body: V1EditFavoritesRequest;
}

/**
 * Request parameters for instrumentsServiceEtfBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceEtfByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceEtfByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceEtfBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceEtfs operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceEtfsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceEtfsRequest {
  /**
   *
   * @type {V1InstrumentsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceEtfs
   */
  readonly body: V1InstrumentsRequest;
}

/**
 * Request parameters for instrumentsServiceFutureBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceFutureByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceFutureByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceFutureBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceFutures operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceFuturesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceFuturesRequest {
  /**
   *
   * @type {V1InstrumentsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceFutures
   */
  readonly body: V1InstrumentsRequest;
}

/**
 * Request parameters for instrumentsServiceGetAccruedInterests operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetAccruedInterestsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetAccruedInterestsRequest {
  /**
   *
   * @type {V1GetAccruedInterestsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetAccruedInterests
   */
  readonly body: V1GetAccruedInterestsRequest;
}

/**
 * Request parameters for instrumentsServiceGetAssetBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetAssetByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetAssetByRequest {
  /**
   *
   * @type {V1AssetRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetAssetBy
   */
  readonly body: V1AssetRequest;
}

/**
 * Request parameters for instrumentsServiceGetAssets operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetAssetsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetAssetsRequest {
  /**
   *
   * @type {object}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetAssets
   */
  readonly body: object;
}

/**
 * Request parameters for instrumentsServiceGetBondCoupons operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetBondCouponsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetBondCouponsRequest {
  /**
   *
   * @type {V1GetBondCouponsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetBondCoupons
   */
  readonly body: V1GetBondCouponsRequest;
}

/**
 * Request parameters for instrumentsServiceGetDividends operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetDividendsRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetDividendsRequest {
  /**
   *
   * @type {V1GetDividendsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetDividends
   */
  readonly body: V1GetDividendsRequest;
}

/**
 * Request parameters for instrumentsServiceGetFavorites operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetFavoritesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetFavoritesRequest {
  /**
   *
   * @type {object}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetFavorites
   */
  readonly body: object;
}

/**
 * Request parameters for instrumentsServiceGetFuturesMargin operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetFuturesMarginRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetFuturesMarginRequest {
  /**
   *
   * @type {V1GetFuturesMarginRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetFuturesMargin
   */
  readonly body: V1GetFuturesMarginRequest;
}

/**
 * Request parameters for instrumentsServiceGetInstrumentBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceGetInstrumentByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceGetInstrumentByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceGetInstrumentBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceShareBy operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceShareByRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceShareByRequest {
  /**
   *
   * @type {V1InstrumentRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceShareBy
   */
  readonly body: V1InstrumentRequest;
}

/**
 * Request parameters for instrumentsServiceShares operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceSharesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceSharesRequest {
  /**
   *
   * @type {V1InstrumentsRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceShares
   */
  readonly body: V1InstrumentsRequest;
}

/**
 * Request parameters for instrumentsServiceTradingSchedules operation in InstrumentsServiceApi.
 * @export
 * @interface InstrumentsServiceApiInstrumentsServiceTradingSchedulesRequest
 */
export interface InstrumentsServiceApiInstrumentsServiceTradingSchedulesRequest {
  /**
   *
   * @type {V1TradingSchedulesRequest}
   * @memberof InstrumentsServiceApiInstrumentsServiceTradingSchedules
   */
  readonly body: V1TradingSchedulesRequest;
}

/**
 * InstrumentsServiceApi - object-oriented interface
 * @export
 * @class InstrumentsServiceApi
 * @extends {BaseAPI}
 */
export class InstrumentsServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод получения облигации по её идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceBondByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceBondBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceBondByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceBondBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка облигаций.
   * @param {InstrumentsServiceApiInstrumentsServiceBondsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceBonds(
    requestParameters: InstrumentsServiceApiInstrumentsServiceBondsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceBonds(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка валют.
   * @param {InstrumentsServiceApiInstrumentsServiceCurrenciesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceCurrencies(
    requestParameters: InstrumentsServiceApiInstrumentsServiceCurrenciesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceCurrencies(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения валюты по её идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceCurrencyByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceCurrencyBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceCurrencyByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceCurrencyBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод редактирования избранных инструментов.
   * @param {InstrumentsServiceApiInstrumentsServiceEditFavoritesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceEditFavorites(
    requestParameters: InstrumentsServiceApiInstrumentsServiceEditFavoritesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceEditFavorites(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения инвестиционного фонда по его идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceEtfByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceEtfBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceEtfByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceEtfBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка инвестиционных фондов.
   * @param {InstrumentsServiceApiInstrumentsServiceEtfsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceEtfs(
    requestParameters: InstrumentsServiceApiInstrumentsServiceEtfsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceEtfs(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения фьючерса по его идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceFutureByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceFutureBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceFutureByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceFutureBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка фьючерсов.
   * @param {InstrumentsServiceApiInstrumentsServiceFuturesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceFutures(
    requestParameters: InstrumentsServiceApiInstrumentsServiceFuturesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceFutures(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения накопленного купонного дохода по облигации.
   * @param {InstrumentsServiceApiInstrumentsServiceGetAccruedInterestsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetAccruedInterests(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetAccruedInterestsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetAccruedInterests(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения актива по его идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceGetAssetByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetAssetBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetAssetByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetAssetBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка активов.
   * @param {InstrumentsServiceApiInstrumentsServiceGetAssetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetAssets(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetAssetsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetAssets(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения графика выплат купонов по облигации
   * @param {InstrumentsServiceApiInstrumentsServiceGetBondCouponsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetBondCoupons(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetBondCouponsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetBondCoupons(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод для получения событий выплаты дивидендов по инструменту.
   * @param {InstrumentsServiceApiInstrumentsServiceGetDividendsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetDividends(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetDividendsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetDividends(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения избранных инструментов.
   * @param {InstrumentsServiceApiInstrumentsServiceGetFavoritesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetFavorites(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetFavoritesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetFavorites(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения размера гарантийного обеспечения по фьючерсам.
   * @param {InstrumentsServiceApiInstrumentsServiceGetFuturesMarginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetFuturesMargin(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetFuturesMarginRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetFuturesMargin(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения основной информации об инструменте.
   * @param {InstrumentsServiceApiInstrumentsServiceGetInstrumentByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceGetInstrumentBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceGetInstrumentByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceGetInstrumentBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения акции по её идентификатору.
   * @param {InstrumentsServiceApiInstrumentsServiceShareByRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceShareBy(
    requestParameters: InstrumentsServiceApiInstrumentsServiceShareByRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceShareBy(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка акций.
   * @param {InstrumentsServiceApiInstrumentsServiceSharesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceShares(
    requestParameters: InstrumentsServiceApiInstrumentsServiceSharesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceShares(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения расписания торгов торговых площадок.
   * @param {InstrumentsServiceApiInstrumentsServiceTradingSchedulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentsServiceApi
   */
  public instrumentsServiceTradingSchedules(
    requestParameters: InstrumentsServiceApiInstrumentsServiceTradingSchedulesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstrumentsServiceApiFp(this.configuration)
      .instrumentsServiceTradingSchedules(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MarketDataServiceApi - axios parameter creator
 * @export
 */
export const MarketDataServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод запроса исторических свечей по инструменту.
     * @param {V1GetCandlesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetCandles: async (
      body: V1GetCandlesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('marketDataServiceGetCandles', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.MarketDataService/GetCandles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод запроса последних цен по инструментам.
     * @param {V1GetLastPricesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetLastPrices: async (
      body: V1GetLastPricesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('marketDataServiceGetLastPrices', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastPrices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод запроса последних обезличенных сделок по инструменту.
     * @param {V1GetLastTradesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetLastTrades: async (
      body: V1GetLastTradesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('marketDataServiceGetLastTrades', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastTrades`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения стакана по инструменту.
     * @param {V1GetOrderBookRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetOrderBook: async (
      body: V1GetOrderBookRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('marketDataServiceGetOrderBook', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.MarketDataService/GetOrderBook`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод запроса статуса торгов по инструментам.
     * @param {V1GetTradingStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetTradingStatus: async (
      body: V1GetTradingStatusRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('marketDataServiceGetTradingStatus', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatus`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MarketDataServiceApi - functional programming interface
 * @export
 */
export const MarketDataServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MarketDataServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод запроса исторических свечей по инструменту.
     * @param {V1GetCandlesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketDataServiceGetCandles(
      body: V1GetCandlesRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetCandlesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataServiceGetCandles(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод запроса последних цен по инструментам.
     * @param {V1GetLastPricesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketDataServiceGetLastPrices(
      body: V1GetLastPricesRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetLastPricesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataServiceGetLastPrices(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод запроса последних обезличенных сделок по инструменту.
     * @param {V1GetLastTradesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketDataServiceGetLastTrades(
      body: V1GetLastTradesRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetLastTradesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataServiceGetLastTrades(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения стакана по инструменту.
     * @param {V1GetOrderBookRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketDataServiceGetOrderBook(
      body: V1GetOrderBookRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetOrderBookResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataServiceGetOrderBook(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод запроса статуса торгов по инструментам.
     * @param {V1GetTradingStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async marketDataServiceGetTradingStatus(
      body: V1GetTradingStatusRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetTradingStatusResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataServiceGetTradingStatus(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * MarketDataServiceApi - factory interface
 * @export
 */
export const MarketDataServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MarketDataServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод запроса исторических свечей по инструменту.
     * @param {V1GetCandlesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetCandles(
      body: V1GetCandlesRequest,
      options?: any,
    ): AxiosPromise<V1GetCandlesResponse> {
      return localVarFp
        .marketDataServiceGetCandles(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод запроса последних цен по инструментам.
     * @param {V1GetLastPricesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetLastPrices(
      body: V1GetLastPricesRequest,
      options?: any,
    ): AxiosPromise<V1GetLastPricesResponse> {
      return localVarFp
        .marketDataServiceGetLastPrices(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод запроса последних обезличенных сделок по инструменту.
     * @param {V1GetLastTradesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetLastTrades(
      body: V1GetLastTradesRequest,
      options?: any,
    ): AxiosPromise<V1GetLastTradesResponse> {
      return localVarFp
        .marketDataServiceGetLastTrades(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения стакана по инструменту.
     * @param {V1GetOrderBookRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetOrderBook(
      body: V1GetOrderBookRequest,
      options?: any,
    ): AxiosPromise<V1GetOrderBookResponse> {
      return localVarFp
        .marketDataServiceGetOrderBook(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод запроса статуса торгов по инструментам.
     * @param {V1GetTradingStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    marketDataServiceGetTradingStatus(
      body: V1GetTradingStatusRequest,
      options?: any,
    ): AxiosPromise<V1GetTradingStatusResponse> {
      return localVarFp
        .marketDataServiceGetTradingStatus(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for marketDataServiceGetCandles operation in MarketDataServiceApi.
 * @export
 * @interface MarketDataServiceApiMarketDataServiceGetCandlesRequest
 */
export interface MarketDataServiceApiMarketDataServiceGetCandlesRequest {
  /**
   *
   * @type {V1GetCandlesRequest}
   * @memberof MarketDataServiceApiMarketDataServiceGetCandles
   */
  readonly body: V1GetCandlesRequest;
}

/**
 * Request parameters for marketDataServiceGetLastPrices operation in MarketDataServiceApi.
 * @export
 * @interface MarketDataServiceApiMarketDataServiceGetLastPricesRequest
 */
export interface MarketDataServiceApiMarketDataServiceGetLastPricesRequest {
  /**
   *
   * @type {V1GetLastPricesRequest}
   * @memberof MarketDataServiceApiMarketDataServiceGetLastPrices
   */
  readonly body: V1GetLastPricesRequest;
}

/**
 * Request parameters for marketDataServiceGetLastTrades operation in MarketDataServiceApi.
 * @export
 * @interface MarketDataServiceApiMarketDataServiceGetLastTradesRequest
 */
export interface MarketDataServiceApiMarketDataServiceGetLastTradesRequest {
  /**
   *
   * @type {V1GetLastTradesRequest}
   * @memberof MarketDataServiceApiMarketDataServiceGetLastTrades
   */
  readonly body: V1GetLastTradesRequest;
}

/**
 * Request parameters for marketDataServiceGetOrderBook operation in MarketDataServiceApi.
 * @export
 * @interface MarketDataServiceApiMarketDataServiceGetOrderBookRequest
 */
export interface MarketDataServiceApiMarketDataServiceGetOrderBookRequest {
  /**
   *
   * @type {V1GetOrderBookRequest}
   * @memberof MarketDataServiceApiMarketDataServiceGetOrderBook
   */
  readonly body: V1GetOrderBookRequest;
}

/**
 * Request parameters for marketDataServiceGetTradingStatus operation in MarketDataServiceApi.
 * @export
 * @interface MarketDataServiceApiMarketDataServiceGetTradingStatusRequest
 */
export interface MarketDataServiceApiMarketDataServiceGetTradingStatusRequest {
  /**
   *
   * @type {V1GetTradingStatusRequest}
   * @memberof MarketDataServiceApiMarketDataServiceGetTradingStatus
   */
  readonly body: V1GetTradingStatusRequest;
}

/**
 * MarketDataServiceApi - object-oriented interface
 * @export
 * @class MarketDataServiceApi
 * @extends {BaseAPI}
 */
export class MarketDataServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод запроса исторических свечей по инструменту.
   * @param {MarketDataServiceApiMarketDataServiceGetCandlesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataServiceApi
   */
  public marketDataServiceGetCandles(
    requestParameters: MarketDataServiceApiMarketDataServiceGetCandlesRequest,
    options?: AxiosRequestConfig,
  ) {
    return MarketDataServiceApiFp(this.configuration)
      .marketDataServiceGetCandles(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод запроса последних цен по инструментам.
   * @param {MarketDataServiceApiMarketDataServiceGetLastPricesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataServiceApi
   */
  public marketDataServiceGetLastPrices(
    requestParameters: MarketDataServiceApiMarketDataServiceGetLastPricesRequest,
    options?: AxiosRequestConfig,
  ) {
    return MarketDataServiceApiFp(this.configuration)
      .marketDataServiceGetLastPrices(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод запроса последних обезличенных сделок по инструменту.
   * @param {MarketDataServiceApiMarketDataServiceGetLastTradesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataServiceApi
   */
  public marketDataServiceGetLastTrades(
    requestParameters: MarketDataServiceApiMarketDataServiceGetLastTradesRequest,
    options?: AxiosRequestConfig,
  ) {
    return MarketDataServiceApiFp(this.configuration)
      .marketDataServiceGetLastTrades(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения стакана по инструменту.
   * @param {MarketDataServiceApiMarketDataServiceGetOrderBookRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataServiceApi
   */
  public marketDataServiceGetOrderBook(
    requestParameters: MarketDataServiceApiMarketDataServiceGetOrderBookRequest,
    options?: AxiosRequestConfig,
  ) {
    return MarketDataServiceApiFp(this.configuration)
      .marketDataServiceGetOrderBook(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод запроса статуса торгов по инструментам.
   * @param {MarketDataServiceApiMarketDataServiceGetTradingStatusRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataServiceApi
   */
  public marketDataServiceGetTradingStatus(
    requestParameters: MarketDataServiceApiMarketDataServiceGetTradingStatusRequest,
    options?: AxiosRequestConfig,
  ) {
    return MarketDataServiceApiFp(this.configuration)
      .marketDataServiceGetTradingStatus(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OperationsServiceApi - axios parameter creator
 * @export
 */
export const OperationsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод получения брокерского отчёта.
     * @param {V1BrokerReportRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetBrokerReport: async (
      body: V1BrokerReportRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetBrokerReport', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetBrokerReport`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения отчёта \"Справка о доходах за пределами РФ\".
     * @param {V1GetDividendsForeignIssuerRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetDividendsForeignIssuer: async (
      body: V1GetDividendsForeignIssuerRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetDividendsForeignIssuer', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetDividendsForeignIssuer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка операций по счёту.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetOperations: async (
      body: V1OperationsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetOperations', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetOperations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения портфеля по счёту.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetPortfolio: async (
      body: V1PortfolioRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetPortfolio', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetPortfolio`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка позиций по счёту.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetPositions: async (
      body: V1PositionsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetPositions', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetPositions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения доступного остатка для вывода средств.
     * @param {V1WithdrawLimitsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetWithdrawLimits: async (
      body: V1WithdrawLimitsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('operationsServiceGetWithdrawLimits', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OperationsService/GetWithdrawLimits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OperationsServiceApi - functional programming interface
 * @export
 */
export const OperationsServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OperationsServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод получения брокерского отчёта.
     * @param {V1BrokerReportRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetBrokerReport(
      body: V1BrokerReportRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BrokerReportResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operationsServiceGetBrokerReport(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения отчёта \"Справка о доходах за пределами РФ\".
     * @param {V1GetDividendsForeignIssuerRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetDividendsForeignIssuer(
      body: V1GetDividendsForeignIssuerRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V1GetDividendsForeignIssuerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.operationsServiceGetDividendsForeignIssuer(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка операций по счёту.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetOperations(
      body: V1OperationsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperationsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operationsServiceGetOperations(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения портфеля по счёту.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetPortfolio(
      body: V1PortfolioRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PortfolioResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operationsServiceGetPortfolio(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка позиций по счёту.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetPositions(
      body: V1PositionsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PositionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operationsServiceGetPositions(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения доступного остатка для вывода средств.
     * @param {V1WithdrawLimitsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operationsServiceGetWithdrawLimits(
      body: V1WithdrawLimitsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1WithdrawLimitsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operationsServiceGetWithdrawLimits(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * OperationsServiceApi - factory interface
 * @export
 */
export const OperationsServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OperationsServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод получения брокерского отчёта.
     * @param {V1BrokerReportRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetBrokerReport(
      body: V1BrokerReportRequest,
      options?: any,
    ): AxiosPromise<V1BrokerReportResponse> {
      return localVarFp
        .operationsServiceGetBrokerReport(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения отчёта \"Справка о доходах за пределами РФ\".
     * @param {V1GetDividendsForeignIssuerRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetDividendsForeignIssuer(
      body: V1GetDividendsForeignIssuerRequest,
      options?: any,
    ): AxiosPromise<V1GetDividendsForeignIssuerResponse> {
      return localVarFp
        .operationsServiceGetDividendsForeignIssuer(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка операций по счёту.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetOperations(
      body: V1OperationsRequest,
      options?: any,
    ): AxiosPromise<V1OperationsResponse> {
      return localVarFp
        .operationsServiceGetOperations(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения портфеля по счёту.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetPortfolio(
      body: V1PortfolioRequest,
      options?: any,
    ): AxiosPromise<V1PortfolioResponse> {
      return localVarFp
        .operationsServiceGetPortfolio(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка позиций по счёту.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetPositions(
      body: V1PositionsRequest,
      options?: any,
    ): AxiosPromise<V1PositionsResponse> {
      return localVarFp
        .operationsServiceGetPositions(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения доступного остатка для вывода средств.
     * @param {V1WithdrawLimitsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operationsServiceGetWithdrawLimits(
      body: V1WithdrawLimitsRequest,
      options?: any,
    ): AxiosPromise<V1WithdrawLimitsResponse> {
      return localVarFp
        .operationsServiceGetWithdrawLimits(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for operationsServiceGetBrokerReport operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetBrokerReportRequest
 */
export interface OperationsServiceApiOperationsServiceGetBrokerReportRequest {
  /**
   *
   * @type {V1BrokerReportRequest}
   * @memberof OperationsServiceApiOperationsServiceGetBrokerReport
   */
  readonly body: V1BrokerReportRequest;
}

/**
 * Request parameters for operationsServiceGetDividendsForeignIssuer operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetDividendsForeignIssuerRequest
 */
export interface OperationsServiceApiOperationsServiceGetDividendsForeignIssuerRequest {
  /**
   *
   * @type {V1GetDividendsForeignIssuerRequest}
   * @memberof OperationsServiceApiOperationsServiceGetDividendsForeignIssuer
   */
  readonly body: V1GetDividendsForeignIssuerRequest;
}

/**
 * Request parameters for operationsServiceGetOperations operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetOperationsRequest
 */
export interface OperationsServiceApiOperationsServiceGetOperationsRequest {
  /**
   *
   * @type {V1OperationsRequest}
   * @memberof OperationsServiceApiOperationsServiceGetOperations
   */
  readonly body: V1OperationsRequest;
}

/**
 * Request parameters for operationsServiceGetPortfolio operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetPortfolioRequest
 */
export interface OperationsServiceApiOperationsServiceGetPortfolioRequest {
  /**
   *
   * @type {V1PortfolioRequest}
   * @memberof OperationsServiceApiOperationsServiceGetPortfolio
   */
  readonly body: V1PortfolioRequest;
}

/**
 * Request parameters for operationsServiceGetPositions operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetPositionsRequest
 */
export interface OperationsServiceApiOperationsServiceGetPositionsRequest {
  /**
   *
   * @type {V1PositionsRequest}
   * @memberof OperationsServiceApiOperationsServiceGetPositions
   */
  readonly body: V1PositionsRequest;
}

/**
 * Request parameters for operationsServiceGetWithdrawLimits operation in OperationsServiceApi.
 * @export
 * @interface OperationsServiceApiOperationsServiceGetWithdrawLimitsRequest
 */
export interface OperationsServiceApiOperationsServiceGetWithdrawLimitsRequest {
  /**
   *
   * @type {V1WithdrawLimitsRequest}
   * @memberof OperationsServiceApiOperationsServiceGetWithdrawLimits
   */
  readonly body: V1WithdrawLimitsRequest;
}

/**
 * OperationsServiceApi - object-oriented interface
 * @export
 * @class OperationsServiceApi
 * @extends {BaseAPI}
 */
export class OperationsServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод получения брокерского отчёта.
   * @param {OperationsServiceApiOperationsServiceGetBrokerReportRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetBrokerReport(
    requestParameters: OperationsServiceApiOperationsServiceGetBrokerReportRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetBrokerReport(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения отчёта \"Справка о доходах за пределами РФ\".
   * @param {OperationsServiceApiOperationsServiceGetDividendsForeignIssuerRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetDividendsForeignIssuer(
    requestParameters: OperationsServiceApiOperationsServiceGetDividendsForeignIssuerRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetDividendsForeignIssuer(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка операций по счёту.
   * @param {OperationsServiceApiOperationsServiceGetOperationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetOperations(
    requestParameters: OperationsServiceApiOperationsServiceGetOperationsRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetOperations(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения портфеля по счёту.
   * @param {OperationsServiceApiOperationsServiceGetPortfolioRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetPortfolio(
    requestParameters: OperationsServiceApiOperationsServiceGetPortfolioRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetPortfolio(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка позиций по счёту.
   * @param {OperationsServiceApiOperationsServiceGetPositionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetPositions(
    requestParameters: OperationsServiceApiOperationsServiceGetPositionsRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetPositions(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения доступного остатка для вывода средств.
   * @param {OperationsServiceApiOperationsServiceGetWithdrawLimitsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsServiceApi
   */
  public operationsServiceGetWithdrawLimits(
    requestParameters: OperationsServiceApiOperationsServiceGetWithdrawLimitsRequest,
    options?: AxiosRequestConfig,
  ) {
    return OperationsServiceApiFp(this.configuration)
      .operationsServiceGetWithdrawLimits(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrdersServiceApi - axios parameter creator
 * @export
 */
export const OrdersServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод отмены биржевой заявки.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceCancelOrder: async (
      body: V1CancelOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ordersServiceCancelOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OrdersService/CancelOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения статуса торгового поручения.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceGetOrderState: async (
      body: V1GetOrderStateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ordersServiceGetOrderState', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OrdersService/GetOrderState`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceGetOrders: async (
      body: V1GetOrdersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ordersServiceGetOrders', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OrdersService/GetOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод выставления заявки.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServicePostOrder: async (
      body: V1PostOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ordersServicePostOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.OrdersService/PostOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrdersServiceApi - functional programming interface
 * @export
 */
export const OrdersServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OrdersServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод отмены биржевой заявки.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersServiceCancelOrder(
      body: V1CancelOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CancelOrderResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ordersServiceCancelOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения статуса торгового поручения.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersServiceGetOrderState(
      body: V1GetOrderStateRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OrderState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ordersServiceGetOrderState(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersServiceGetOrders(
      body: V1GetOrdersRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetOrdersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ordersServiceGetOrders(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод выставления заявки.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersServicePostOrder(
      body: V1PostOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PostOrderResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ordersServicePostOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * OrdersServiceApi - factory interface
 * @export
 */
export const OrdersServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OrdersServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод отмены биржевой заявки.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceCancelOrder(
      body: V1CancelOrderRequest,
      options?: any,
    ): AxiosPromise<V1CancelOrderResponse> {
      return localVarFp
        .ordersServiceCancelOrder(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения статуса торгового поручения.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceGetOrderState(
      body: V1GetOrderStateRequest,
      options?: any,
    ): AxiosPromise<V1OrderState> {
      return localVarFp
        .ordersServiceGetOrderState(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServiceGetOrders(
      body: V1GetOrdersRequest,
      options?: any,
    ): AxiosPromise<V1GetOrdersResponse> {
      return localVarFp
        .ordersServiceGetOrders(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод выставления заявки.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersServicePostOrder(
      body: V1PostOrderRequest,
      options?: any,
    ): AxiosPromise<V1PostOrderResponse> {
      return localVarFp
        .ordersServicePostOrder(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for ordersServiceCancelOrder operation in OrdersServiceApi.
 * @export
 * @interface OrdersServiceApiOrdersServiceCancelOrderRequest
 */
export interface OrdersServiceApiOrdersServiceCancelOrderRequest {
  /**
   *
   * @type {V1CancelOrderRequest}
   * @memberof OrdersServiceApiOrdersServiceCancelOrder
   */
  readonly body: V1CancelOrderRequest;
}

/**
 * Request parameters for ordersServiceGetOrderState operation in OrdersServiceApi.
 * @export
 * @interface OrdersServiceApiOrdersServiceGetOrderStateRequest
 */
export interface OrdersServiceApiOrdersServiceGetOrderStateRequest {
  /**
   *
   * @type {V1GetOrderStateRequest}
   * @memberof OrdersServiceApiOrdersServiceGetOrderState
   */
  readonly body: V1GetOrderStateRequest;
}

/**
 * Request parameters for ordersServiceGetOrders operation in OrdersServiceApi.
 * @export
 * @interface OrdersServiceApiOrdersServiceGetOrdersRequest
 */
export interface OrdersServiceApiOrdersServiceGetOrdersRequest {
  /**
   *
   * @type {V1GetOrdersRequest}
   * @memberof OrdersServiceApiOrdersServiceGetOrders
   */
  readonly body: V1GetOrdersRequest;
}

/**
 * Request parameters for ordersServicePostOrder operation in OrdersServiceApi.
 * @export
 * @interface OrdersServiceApiOrdersServicePostOrderRequest
 */
export interface OrdersServiceApiOrdersServicePostOrderRequest {
  /**
   *
   * @type {V1PostOrderRequest}
   * @memberof OrdersServiceApiOrdersServicePostOrder
   */
  readonly body: V1PostOrderRequest;
}

/**
 * OrdersServiceApi - object-oriented interface
 * @export
 * @class OrdersServiceApi
 * @extends {BaseAPI}
 */
export class OrdersServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод отмены биржевой заявки.
   * @param {OrdersServiceApiOrdersServiceCancelOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrdersServiceApi
   */
  public ordersServiceCancelOrder(
    requestParameters: OrdersServiceApiOrdersServiceCancelOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return OrdersServiceApiFp(this.configuration)
      .ordersServiceCancelOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения статуса торгового поручения.
   * @param {OrdersServiceApiOrdersServiceGetOrderStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrdersServiceApi
   */
  public ordersServiceGetOrderState(
    requestParameters: OrdersServiceApiOrdersServiceGetOrderStateRequest,
    options?: AxiosRequestConfig,
  ) {
    return OrdersServiceApiFp(this.configuration)
      .ordersServiceGetOrderState(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка активных заявок по счёту.
   * @param {OrdersServiceApiOrdersServiceGetOrdersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrdersServiceApi
   */
  public ordersServiceGetOrders(
    requestParameters: OrdersServiceApiOrdersServiceGetOrdersRequest,
    options?: AxiosRequestConfig,
  ) {
    return OrdersServiceApiFp(this.configuration)
      .ordersServiceGetOrders(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод выставления заявки.
   * @param {OrdersServiceApiOrdersServicePostOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrdersServiceApi
   */
  public ordersServicePostOrder(
    requestParameters: OrdersServiceApiOrdersServicePostOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return OrdersServiceApiFp(this.configuration)
      .ordersServicePostOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SandboxServiceApi - axios parameter creator
 * @export
 */
export const SandboxServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод отмены торгового поручения в песочнице.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceCancelSandboxOrder: async (
      body: V1CancelOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceCancelSandboxOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/CancelSandboxOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод закрытия счёта в песочнице.
     * @param {V1CloseSandboxAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceCloseSandboxAccount: async (
      body: V1CloseSandboxAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceCloseSandboxAccount', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/CloseSandboxAccount`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения счетов в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxAccounts: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxAccounts', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxAccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения операций в песочнице по номеру счёта.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOperations: async (
      body: V1OperationsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxOperations', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOperations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения статуса заявки в песочнице.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOrderState: async (
      body: V1GetOrderStateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxOrderState', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrderState`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту в песочнице.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOrders: async (
      body: V1GetOrdersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxOrders', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения портфолио в песочнице.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxPortfolio: async (
      body: V1PortfolioRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxPortfolio', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPortfolio`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения позиций по виртуальному счёту песочницы.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxPositions: async (
      body: V1PositionsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceGetSandboxPositions', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPositions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод регистрации счёта в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceOpenSandboxAccount: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceOpenSandboxAccount', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/OpenSandboxAccount`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод выставления торгового поручения в песочнице.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServicePostSandboxOrder: async (
      body: V1PostOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServicePostSandboxOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/PostSandboxOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод пополнения счёта в песочнице.
     * @param {V1SandboxPayInRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceSandboxPayIn: async (
      body: V1SandboxPayInRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sandboxServiceSandboxPayIn', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.SandboxService/SandboxPayIn`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SandboxServiceApi - functional programming interface
 * @export
 */
export const SandboxServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SandboxServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод отмены торгового поручения в песочнице.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceCancelSandboxOrder(
      body: V1CancelOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CancelOrderResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceCancelSandboxOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод закрытия счёта в песочнице.
     * @param {V1CloseSandboxAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceCloseSandboxAccount(
      body: V1CloseSandboxAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceCloseSandboxAccount(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения счетов в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxAccounts(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxAccounts(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения операций в песочнице по номеру счёта.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxOperations(
      body: V1OperationsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperationsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxOperations(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения статуса заявки в песочнице.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxOrderState(
      body: V1GetOrderStateRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OrderState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxOrderState(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту в песочнице.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxOrders(
      body: V1GetOrdersRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetOrdersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxOrders(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения портфолио в песочнице.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxPortfolio(
      body: V1PortfolioRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PortfolioResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxPortfolio(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения позиций по виртуальному счёту песочницы.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceGetSandboxPositions(
      body: V1PositionsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PositionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceGetSandboxPositions(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод регистрации счёта в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceOpenSandboxAccount(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OpenSandboxAccountResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceOpenSandboxAccount(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод выставления торгового поручения в песочнице.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServicePostSandboxOrder(
      body: V1PostOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PostOrderResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServicePostSandboxOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод пополнения счёта в песочнице.
     * @param {V1SandboxPayInRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sandboxServiceSandboxPayIn(
      body: V1SandboxPayInRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1SandboxPayInResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxServiceSandboxPayIn(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SandboxServiceApi - factory interface
 * @export
 */
export const SandboxServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SandboxServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод отмены торгового поручения в песочнице.
     * @param {V1CancelOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceCancelSandboxOrder(
      body: V1CancelOrderRequest,
      options?: any,
    ): AxiosPromise<V1CancelOrderResponse> {
      return localVarFp
        .sandboxServiceCancelSandboxOrder(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод закрытия счёта в песочнице.
     * @param {V1CloseSandboxAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceCloseSandboxAccount(
      body: V1CloseSandboxAccountRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .sandboxServiceCloseSandboxAccount(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения счетов в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxAccounts(
      body: object,
      options?: any,
    ): AxiosPromise<V1GetAccountsResponse> {
      return localVarFp
        .sandboxServiceGetSandboxAccounts(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения операций в песочнице по номеру счёта.
     * @param {V1OperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOperations(
      body: V1OperationsRequest,
      options?: any,
    ): AxiosPromise<V1OperationsResponse> {
      return localVarFp
        .sandboxServiceGetSandboxOperations(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения статуса заявки в песочнице.
     * @param {V1GetOrderStateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOrderState(
      body: V1GetOrderStateRequest,
      options?: any,
    ): AxiosPromise<V1OrderState> {
      return localVarFp
        .sandboxServiceGetSandboxOrderState(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка активных заявок по счёту в песочнице.
     * @param {V1GetOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxOrders(
      body: V1GetOrdersRequest,
      options?: any,
    ): AxiosPromise<V1GetOrdersResponse> {
      return localVarFp
        .sandboxServiceGetSandboxOrders(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения портфолио в песочнице.
     * @param {V1PortfolioRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxPortfolio(
      body: V1PortfolioRequest,
      options?: any,
    ): AxiosPromise<V1PortfolioResponse> {
      return localVarFp
        .sandboxServiceGetSandboxPortfolio(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения позиций по виртуальному счёту песочницы.
     * @param {V1PositionsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceGetSandboxPositions(
      body: V1PositionsRequest,
      options?: any,
    ): AxiosPromise<V1PositionsResponse> {
      return localVarFp
        .sandboxServiceGetSandboxPositions(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод регистрации счёта в песочнице.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceOpenSandboxAccount(
      body: object,
      options?: any,
    ): AxiosPromise<V1OpenSandboxAccountResponse> {
      return localVarFp
        .sandboxServiceOpenSandboxAccount(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод выставления торгового поручения в песочнице.
     * @param {V1PostOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServicePostSandboxOrder(
      body: V1PostOrderRequest,
      options?: any,
    ): AxiosPromise<V1PostOrderResponse> {
      return localVarFp
        .sandboxServicePostSandboxOrder(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод пополнения счёта в песочнице.
     * @param {V1SandboxPayInRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sandboxServiceSandboxPayIn(
      body: V1SandboxPayInRequest,
      options?: any,
    ): AxiosPromise<V1SandboxPayInResponse> {
      return localVarFp
        .sandboxServiceSandboxPayIn(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for sandboxServiceCancelSandboxOrder operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceCancelSandboxOrderRequest
 */
export interface SandboxServiceApiSandboxServiceCancelSandboxOrderRequest {
  /**
   *
   * @type {V1CancelOrderRequest}
   * @memberof SandboxServiceApiSandboxServiceCancelSandboxOrder
   */
  readonly body: V1CancelOrderRequest;
}

/**
 * Request parameters for sandboxServiceCloseSandboxAccount operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceCloseSandboxAccountRequest
 */
export interface SandboxServiceApiSandboxServiceCloseSandboxAccountRequest {
  /**
   *
   * @type {V1CloseSandboxAccountRequest}
   * @memberof SandboxServiceApiSandboxServiceCloseSandboxAccount
   */
  readonly body: V1CloseSandboxAccountRequest;
}

/**
 * Request parameters for sandboxServiceGetSandboxAccounts operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxAccountsRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxAccountsRequest {
  /**
   *
   * @type {object}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxAccounts
   */
  readonly body: object;
}

/**
 * Request parameters for sandboxServiceGetSandboxOperations operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxOperationsRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxOperationsRequest {
  /**
   *
   * @type {V1OperationsRequest}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxOperations
   */
  readonly body: V1OperationsRequest;
}

/**
 * Request parameters for sandboxServiceGetSandboxOrderState operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxOrderStateRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxOrderStateRequest {
  /**
   *
   * @type {V1GetOrderStateRequest}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxOrderState
   */
  readonly body: V1GetOrderStateRequest;
}

/**
 * Request parameters for sandboxServiceGetSandboxOrders operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxOrdersRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxOrdersRequest {
  /**
   *
   * @type {V1GetOrdersRequest}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxOrders
   */
  readonly body: V1GetOrdersRequest;
}

/**
 * Request parameters for sandboxServiceGetSandboxPortfolio operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxPortfolioRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxPortfolioRequest {
  /**
   *
   * @type {V1PortfolioRequest}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxPortfolio
   */
  readonly body: V1PortfolioRequest;
}

/**
 * Request parameters for sandboxServiceGetSandboxPositions operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceGetSandboxPositionsRequest
 */
export interface SandboxServiceApiSandboxServiceGetSandboxPositionsRequest {
  /**
   *
   * @type {V1PositionsRequest}
   * @memberof SandboxServiceApiSandboxServiceGetSandboxPositions
   */
  readonly body: V1PositionsRequest;
}

/**
 * Request parameters for sandboxServiceOpenSandboxAccount operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceOpenSandboxAccountRequest
 */
export interface SandboxServiceApiSandboxServiceOpenSandboxAccountRequest {
  /**
   *
   * @type {object}
   * @memberof SandboxServiceApiSandboxServiceOpenSandboxAccount
   */
  readonly body: object;
}

/**
 * Request parameters for sandboxServicePostSandboxOrder operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServicePostSandboxOrderRequest
 */
export interface SandboxServiceApiSandboxServicePostSandboxOrderRequest {
  /**
   *
   * @type {V1PostOrderRequest}
   * @memberof SandboxServiceApiSandboxServicePostSandboxOrder
   */
  readonly body: V1PostOrderRequest;
}

/**
 * Request parameters for sandboxServiceSandboxPayIn operation in SandboxServiceApi.
 * @export
 * @interface SandboxServiceApiSandboxServiceSandboxPayInRequest
 */
export interface SandboxServiceApiSandboxServiceSandboxPayInRequest {
  /**
   *
   * @type {V1SandboxPayInRequest}
   * @memberof SandboxServiceApiSandboxServiceSandboxPayIn
   */
  readonly body: V1SandboxPayInRequest;
}

/**
 * SandboxServiceApi - object-oriented interface
 * @export
 * @class SandboxServiceApi
 * @extends {BaseAPI}
 */
export class SandboxServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод отмены торгового поручения в песочнице.
   * @param {SandboxServiceApiSandboxServiceCancelSandboxOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceCancelSandboxOrder(
    requestParameters: SandboxServiceApiSandboxServiceCancelSandboxOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceCancelSandboxOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод закрытия счёта в песочнице.
   * @param {SandboxServiceApiSandboxServiceCloseSandboxAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceCloseSandboxAccount(
    requestParameters: SandboxServiceApiSandboxServiceCloseSandboxAccountRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceCloseSandboxAccount(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения счетов в песочнице.
   * @param {SandboxServiceApiSandboxServiceGetSandboxAccountsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxAccounts(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxAccountsRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxAccounts(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения операций в песочнице по номеру счёта.
   * @param {SandboxServiceApiSandboxServiceGetSandboxOperationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxOperations(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxOperationsRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxOperations(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения статуса заявки в песочнице.
   * @param {SandboxServiceApiSandboxServiceGetSandboxOrderStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxOrderState(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxOrderStateRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxOrderState(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка активных заявок по счёту в песочнице.
   * @param {SandboxServiceApiSandboxServiceGetSandboxOrdersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxOrders(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxOrdersRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxOrders(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения портфолио в песочнице.
   * @param {SandboxServiceApiSandboxServiceGetSandboxPortfolioRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxPortfolio(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxPortfolioRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxPortfolio(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения позиций по виртуальному счёту песочницы.
   * @param {SandboxServiceApiSandboxServiceGetSandboxPositionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceGetSandboxPositions(
    requestParameters: SandboxServiceApiSandboxServiceGetSandboxPositionsRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceGetSandboxPositions(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод регистрации счёта в песочнице.
   * @param {SandboxServiceApiSandboxServiceOpenSandboxAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceOpenSandboxAccount(
    requestParameters: SandboxServiceApiSandboxServiceOpenSandboxAccountRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceOpenSandboxAccount(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод выставления торгового поручения в песочнице.
   * @param {SandboxServiceApiSandboxServicePostSandboxOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServicePostSandboxOrder(
    requestParameters: SandboxServiceApiSandboxServicePostSandboxOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServicePostSandboxOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод пополнения счёта в песочнице.
   * @param {SandboxServiceApiSandboxServiceSandboxPayInRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SandboxServiceApi
   */
  public sandboxServiceSandboxPayIn(
    requestParameters: SandboxServiceApiSandboxServiceSandboxPayInRequest,
    options?: AxiosRequestConfig,
  ) {
    return SandboxServiceApiFp(this.configuration)
      .sandboxServiceSandboxPayIn(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StopOrdersServiceApi - axios parameter creator
 * @export
 */
export const StopOrdersServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод отмены стоп-заявки.
     * @param {V1CancelStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServiceCancelStopOrder: async (
      body: V1CancelStopOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('stopOrdersServiceCancelStopOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.StopOrdersService/CancelStopOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения списка активных стоп заявок по счёту.
     * @param {V1GetStopOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServiceGetStopOrders: async (
      body: V1GetStopOrdersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('stopOrdersServiceGetStopOrders', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.StopOrdersService/GetStopOrders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод выставления стоп-заявки.
     * @param {V1PostStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServicePostStopOrder: async (
      body: V1PostStopOrderRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('stopOrdersServicePostStopOrder', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.StopOrdersService/PostStopOrder`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StopOrdersServiceApi - functional programming interface
 * @export
 */
export const StopOrdersServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StopOrdersServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод отмены стоп-заявки.
     * @param {V1CancelStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopOrdersServiceCancelStopOrder(
      body: V1CancelStopOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CancelStopOrderResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopOrdersServiceCancelStopOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения списка активных стоп заявок по счёту.
     * @param {V1GetStopOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopOrdersServiceGetStopOrders(
      body: V1GetStopOrdersRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetStopOrdersResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopOrdersServiceGetStopOrders(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод выставления стоп-заявки.
     * @param {V1PostStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stopOrdersServicePostStopOrder(
      body: V1PostStopOrderRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1PostStopOrderResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stopOrdersServicePostStopOrder(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * StopOrdersServiceApi - factory interface
 * @export
 */
export const StopOrdersServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StopOrdersServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод отмены стоп-заявки.
     * @param {V1CancelStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServiceCancelStopOrder(
      body: V1CancelStopOrderRequest,
      options?: any,
    ): AxiosPromise<V1CancelStopOrderResponse> {
      return localVarFp
        .stopOrdersServiceCancelStopOrder(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения списка активных стоп заявок по счёту.
     * @param {V1GetStopOrdersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServiceGetStopOrders(
      body: V1GetStopOrdersRequest,
      options?: any,
    ): AxiosPromise<V1GetStopOrdersResponse> {
      return localVarFp
        .stopOrdersServiceGetStopOrders(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод выставления стоп-заявки.
     * @param {V1PostStopOrderRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopOrdersServicePostStopOrder(
      body: V1PostStopOrderRequest,
      options?: any,
    ): AxiosPromise<V1PostStopOrderResponse> {
      return localVarFp
        .stopOrdersServicePostStopOrder(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for stopOrdersServiceCancelStopOrder operation in StopOrdersServiceApi.
 * @export
 * @interface StopOrdersServiceApiStopOrdersServiceCancelStopOrderRequest
 */
export interface StopOrdersServiceApiStopOrdersServiceCancelStopOrderRequest {
  /**
   *
   * @type {V1CancelStopOrderRequest}
   * @memberof StopOrdersServiceApiStopOrdersServiceCancelStopOrder
   */
  readonly body: V1CancelStopOrderRequest;
}

/**
 * Request parameters for stopOrdersServiceGetStopOrders operation in StopOrdersServiceApi.
 * @export
 * @interface StopOrdersServiceApiStopOrdersServiceGetStopOrdersRequest
 */
export interface StopOrdersServiceApiStopOrdersServiceGetStopOrdersRequest {
  /**
   *
   * @type {V1GetStopOrdersRequest}
   * @memberof StopOrdersServiceApiStopOrdersServiceGetStopOrders
   */
  readonly body: V1GetStopOrdersRequest;
}

/**
 * Request parameters for stopOrdersServicePostStopOrder operation in StopOrdersServiceApi.
 * @export
 * @interface StopOrdersServiceApiStopOrdersServicePostStopOrderRequest
 */
export interface StopOrdersServiceApiStopOrdersServicePostStopOrderRequest {
  /**
   *
   * @type {V1PostStopOrderRequest}
   * @memberof StopOrdersServiceApiStopOrdersServicePostStopOrder
   */
  readonly body: V1PostStopOrderRequest;
}

/**
 * StopOrdersServiceApi - object-oriented interface
 * @export
 * @class StopOrdersServiceApi
 * @extends {BaseAPI}
 */
export class StopOrdersServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод отмены стоп-заявки.
   * @param {StopOrdersServiceApiStopOrdersServiceCancelStopOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopOrdersServiceApi
   */
  public stopOrdersServiceCancelStopOrder(
    requestParameters: StopOrdersServiceApiStopOrdersServiceCancelStopOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopOrdersServiceApiFp(this.configuration)
      .stopOrdersServiceCancelStopOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения списка активных стоп заявок по счёту.
   * @param {StopOrdersServiceApiStopOrdersServiceGetStopOrdersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopOrdersServiceApi
   */
  public stopOrdersServiceGetStopOrders(
    requestParameters: StopOrdersServiceApiStopOrdersServiceGetStopOrdersRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopOrdersServiceApiFp(this.configuration)
      .stopOrdersServiceGetStopOrders(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод выставления стоп-заявки.
   * @param {StopOrdersServiceApiStopOrdersServicePostStopOrderRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StopOrdersServiceApi
   */
  public stopOrdersServicePostStopOrder(
    requestParameters: StopOrdersServiceApiStopOrdersServicePostStopOrderRequest,
    options?: AxiosRequestConfig,
  ) {
    return StopOrdersServiceApiFp(this.configuration)
      .stopOrdersServicePostStopOrder(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersServiceApi - axios parameter creator
 * @export
 */
export const UsersServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Метод получения счетов пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetAccounts: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('usersServiceGetAccounts', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.UsersService/GetAccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Метод получения информации о пользователе.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetInfo: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('usersServiceGetInfo', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.UsersService/GetInfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Расчёт маржинальных показателей по счёту.
     * @param {V1GetMarginAttributesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetMarginAttributes: async (
      body: V1GetMarginAttributesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('usersServiceGetMarginAttributes', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.UsersService/GetMarginAttributes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Запрос тарифа пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetUserTariff: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('usersServiceGetUserTariff', 'body', body);
      const localVarPath = `/tinkoff.public.invest.api.contract.v1.UsersService/GetUserTariff`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersServiceApi - functional programming interface
 * @export
 */
export const UsersServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Метод получения счетов пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersServiceGetAccounts(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersServiceGetAccounts(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Метод получения информации о пользователе.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersServiceGetInfo(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersServiceGetInfo(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Расчёт маржинальных показателей по счёту.
     * @param {V1GetMarginAttributesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersServiceGetMarginAttributes(
      body: V1GetMarginAttributesRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetMarginAttributesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersServiceGetMarginAttributes(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Запрос тарифа пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersServiceGetUserTariff(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUserTariffResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersServiceGetUserTariff(
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UsersServiceApi - factory interface
 * @export
 */
export const UsersServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Метод получения счетов пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetAccounts(body: object, options?: any): AxiosPromise<V1GetAccountsResponse> {
      return localVarFp
        .usersServiceGetAccounts(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Метод получения информации о пользователе.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetInfo(body: object, options?: any): AxiosPromise<V1GetInfoResponse> {
      return localVarFp
        .usersServiceGetInfo(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Расчёт маржинальных показателей по счёту.
     * @param {V1GetMarginAttributesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetMarginAttributes(
      body: V1GetMarginAttributesRequest,
      options?: any,
    ): AxiosPromise<V1GetMarginAttributesResponse> {
      return localVarFp
        .usersServiceGetMarginAttributes(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Запрос тарифа пользователя.
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersServiceGetUserTariff(body: object, options?: any): AxiosPromise<V1GetUserTariffResponse> {
      return localVarFp
        .usersServiceGetUserTariff(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for usersServiceGetAccounts operation in UsersServiceApi.
 * @export
 * @interface UsersServiceApiUsersServiceGetAccountsRequest
 */
export interface UsersServiceApiUsersServiceGetAccountsRequest {
  /**
   *
   * @type {object}
   * @memberof UsersServiceApiUsersServiceGetAccounts
   */
  readonly body: object;
}

/**
 * Request parameters for usersServiceGetInfo operation in UsersServiceApi.
 * @export
 * @interface UsersServiceApiUsersServiceGetInfoRequest
 */
export interface UsersServiceApiUsersServiceGetInfoRequest {
  /**
   *
   * @type {object}
   * @memberof UsersServiceApiUsersServiceGetInfo
   */
  readonly body: object;
}

/**
 * Request parameters for usersServiceGetMarginAttributes operation in UsersServiceApi.
 * @export
 * @interface UsersServiceApiUsersServiceGetMarginAttributesRequest
 */
export interface UsersServiceApiUsersServiceGetMarginAttributesRequest {
  /**
   *
   * @type {V1GetMarginAttributesRequest}
   * @memberof UsersServiceApiUsersServiceGetMarginAttributes
   */
  readonly body: V1GetMarginAttributesRequest;
}

/**
 * Request parameters for usersServiceGetUserTariff operation in UsersServiceApi.
 * @export
 * @interface UsersServiceApiUsersServiceGetUserTariffRequest
 */
export interface UsersServiceApiUsersServiceGetUserTariffRequest {
  /**
   *
   * @type {object}
   * @memberof UsersServiceApiUsersServiceGetUserTariff
   */
  readonly body: object;
}

/**
 * UsersServiceApi - object-oriented interface
 * @export
 * @class UsersServiceApi
 * @extends {BaseAPI}
 */
export class UsersServiceApi extends BaseAPI {
  /**
   *
   * @summary Метод получения счетов пользователя.
   * @param {UsersServiceApiUsersServiceGetAccountsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersServiceApi
   */
  public usersServiceGetAccounts(
    requestParameters: UsersServiceApiUsersServiceGetAccountsRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersServiceApiFp(this.configuration)
      .usersServiceGetAccounts(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Метод получения информации о пользователе.
   * @param {UsersServiceApiUsersServiceGetInfoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersServiceApi
   */
  public usersServiceGetInfo(
    requestParameters: UsersServiceApiUsersServiceGetInfoRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersServiceApiFp(this.configuration)
      .usersServiceGetInfo(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Расчёт маржинальных показателей по счёту.
   * @param {UsersServiceApiUsersServiceGetMarginAttributesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersServiceApi
   */
  public usersServiceGetMarginAttributes(
    requestParameters: UsersServiceApiUsersServiceGetMarginAttributesRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersServiceApiFp(this.configuration)
      .usersServiceGetMarginAttributes(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Запрос тарифа пользователя.
   * @param {UsersServiceApiUsersServiceGetUserTariffRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersServiceApi
   */
  public usersServiceGetUserTariff(
    requestParameters: UsersServiceApiUsersServiceGetUserTariffRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersServiceApiFp(this.configuration)
      .usersServiceGetUserTariff(requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
